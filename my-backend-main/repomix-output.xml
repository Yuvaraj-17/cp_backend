This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
mvnw
mvnw.cmd
pom.xml
src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java
src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java
src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java
src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java
src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java
src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java
src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java
src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java
src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java
src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java
src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java
src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java
src/main/java/in/crewplay/crewplay_backend/domain/team/enums/TeamStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/team/Team.java
src/main/java/in/crewplay/crewplay_backend/domain/team/TeamMember.java
src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java
src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java
src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java
src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java
src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/User.java
src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java
src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Controller/TeamRosterController.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Repository/TeamMemberRepository.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Service/TeamRosterService.java
src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java
src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java
src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java
src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java
src/main/java/in/crewplay/crewplay_backend/team/Repository/TeamRepository.java
src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java
src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java
src/main/resources/application.yaml
src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.10</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>in.crewplay</groupId>
	<artifactId>crewplay-backend</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>crewplay-backend</name>
	<description>Demo project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<!-- JWT -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>

		<!-- Mail -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java">
package in.crewplay.crewplay_backend.Auth.Controller;


import in.crewplay.crewplay_backend.Auth.DTO.Request.RequestOtpRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.StartJourneyRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.VerifyOtpRequest;
import in.crewplay.crewplay_backend.Auth.service.EmailService;
import in.crewplay.crewplay_backend.Auth.util.JwtUtil;
import in.crewplay.crewplay_backend.Auth.service.OtpService;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRoleRepository;
import in.crewplay.crewplay_backend.domain.user.Role;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.UserRole;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/auth")
public class AuthController {

    private final OtpService otpService;
    private final EmailService emailService;
    private final UserRepository userRepository;
    private final UserRoleRepository userRoleRepository;
    private final JwtUtil jwtUtil;

    public AuthController(
            OtpService otpService,
            EmailService emailService,
            UserRepository userRepository,
            UserRoleRepository userRoleRepository,
            JwtUtil jwtUtil
    ) {
        this.otpService = otpService;
        this.emailService = emailService;
        this.userRepository = userRepository;
        this.userRoleRepository = userRoleRepository;
        this.jwtUtil = jwtUtil;
    }

    /**
     * STEP 1 ‚Äî REQUEST OTP (Signup + Login)
     */
    @PostMapping("/request-otp")
    public void requestOtp(@Valid @RequestBody RequestOtpRequest request) {
        String otp = otpService.generateAndStoreOtp(request.getEmail());
        emailService.sendOtpEmail(request.getEmail(), otp);
    }

    /**
     * STEP 2 ‚Äî VERIFY OTP (Identity Proven)
     */
    @PostMapping("/verify-otp")
    public Long verifyOtp(@Valid @RequestBody VerifyOtpRequest request) {

        boolean valid = otpService.verifyOtp(request.getEmail(), request.getOtp());
        if (!valid) {
            throw new RuntimeException("Invalid or expired OTP");
        }

        User user = userRepository.findByEmail(request.getEmail())
                .orElseGet(() -> {
                    User newUser = new User();
                    newUser.setEmail(request.getEmail());
                    return userRepository.save(newUser);
                });

        // Frontend only needs userId at this stage
        return user.getId();
    }

    /**
     * STEP 3 ‚Äî START JOURNEY (ONE ACTIVE ROLE GUARANTEED)
     */
    @PostMapping("/start-journey/{userId}")
    public String startJourney(
            @PathVariable Long userId,
            @Valid @RequestBody StartJourneyRequest request
    ) {
        Role selectedRole = request.getRole();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // 1Ô∏è‚É£ Deactivate ALL existing roles
        List<UserRole> existingRoles = userRoleRepository.findByUserId(userId);
        existingRoles.forEach(ur -> ur.setIsActive(false));
        userRoleRepository.saveAll(existingRoles);

        // 2Ô∏è‚É£ Activate or create the selected role
        UserRole currentRole = userRoleRepository
                .findByUserIdAndRole(userId, selectedRole)
                .orElseGet(() -> {
                    UserRole ur = new UserRole();
                    ur.setUser(user);
                    ur.setRole(selectedRole);
                    return ur;
                });

        currentRole.setIsActive(true);
        userRoleRepository.save(currentRole);

        // 3Ô∏è‚É£ Collect ALL roles owned by user (for JWT)
        List<String> roleNames = userRoleRepository.findByUserId(userId)
                .stream()
                .map(ur -> ur.getRole().name())
                .toList();

        // 4Ô∏è‚É£ Issue JWT with ACTIVE ROLE
        return jwtUtil.generateToken(
                userId,
                roleNames,
                selectedRole.name()
        );
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RequestOtpRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import in.crewplay.crewplay_backend.domain.user.Role;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class StartJourneyRequest {

    @NotNull(message = "Role must be selected")
    private Role role;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyOtpRequest {

    @NotBlank
    @Email
    private String email;

    @NotBlank(message = "OTP is required")
    private String otp;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailService {

    private final JavaMailSender mailSender;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendOtpEmail(String to, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject("CrewPlay Login OTP");
        message.setText("Your OTP is: " + otp + "\nValid for 5 minutes.");
        mailSender.send(message);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Random;

@Service
public class OtpService {

    private final StringRedisTemplate redisTemplate;
    private static final int OTP_TTL_MINUTES = 5;

    public OtpService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public String generateAndStoreOtp(String email) {
        String otp = String.valueOf(100000 + new Random().nextInt(900000));
        redisTemplate.opsForValue()
                .set("otp:" + email, otp, Duration.ofMinutes(OTP_TTL_MINUTES));
        return otp;
    }

    public boolean verifyOtp(String email, String otp) {
        String key = "otp:" + email;
        String storedOtp = redisTemplate.opsForValue().get(key);

        if (storedOtp != null && storedOtp.equals(otp)) {
            redisTemplate.delete(key); // one-time use
            return true;
        }
        return false;
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.List;

@Component
public class JwtTokenParser {

    @Value("${jwt.secret}")
    private String secret;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    // ‚úÖ VALIDATE TOKEN SAFELY
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException |
                 MalformedJwtException |
                 ExpiredJwtException |
                 IllegalArgumentException e) {

            // In real prod ‚Üí use logger
            System.out.println("Invalid JWT: " + e.getMessage());
            return false;
        }
    }

    private Claims getAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public Long extractUserId(String token) {
        return Long.parseLong(getAllClaims(token).getSubject());
    }

    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        return (List<String>) getAllClaims(token).get("roles");
    }

    public String extractActiveRole(String token) {
        return (String) getAllClaims(token).get("active_role");
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Long userId, List<String> roles, String activeRole) {
        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .claim("roles", roles)
                .claim("active_role", activeRole)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java">
package in.crewplay.crewplay_backend.common.enums;

public class MatchStatus {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java">
package in.crewplay.crewplay_backend.common.enums;

public class PlayingRole {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java">
package in.crewplay.crewplay_backend.common.enums;

public class TeamVisibility {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java">
package in.crewplay.crewplay_backend.common;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationErrors(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors()
                .forEach(err -> errors.put(err.getField(), err.getDefaultMessage()));

        return ResponseEntity.badRequest().body(errors);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java">
package in.crewplay.crewplay_backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CrewplayBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(CrewplayBackendApplication.class, args);
	}




}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BallType {
    TENNIS,
    LEATHER,
    CORK,
    STUMPER

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BattingHand {
    LEFT,
    RIGHT
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BowlingType {

        RIGHT_ARM_FAST,
        RIGHT_ARM_FAST_MEDIUM,
        RIGHT_ARM_MEDIUM,
        RIGHT_ARM_OFF_SPIN,
        RIGHT_ARM_LEG_SPIN,

        LEFT_ARM_FAST,
        LEFT_ARM_MEDIUM,
        LEFT_ARM_ORTHODOX,
        LEFT_ARM_WRIST_SPIN

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.SubmitSquadRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchController {

    private final MatchService matchService;

    /**
     * üî• SINGLE ENTRY POINT ‚Äî PHASE-0
     * Called ONLY when scorer clicks "Start Match"
     *
     * Flow:
     * UI navigation (Quick Match, Select Teams, Select Squads) ‚Üí frontend only
     * Final "Proceed" button ‚Üí THIS API
     */
    @PostMapping("/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Match> startMatch(
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody SubmitSquadRequest request
    ) {
        Match match = matchService.startMatch(scorerUserId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchRoleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchRoleController {

    private final MatchRoleService matchRoleService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}/assign-roles")
    public ResponseEntity<?> assignRoles(
            @PathVariable Long matchId,
            @Valid @RequestBody AssignSquadRolesRequest request
    ) {
        matchRoleService.assignRoles(matchId, request);
        return ResponseEntity.ok().build();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchSpecsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/specs")
@RequiredArgsConstructor
public class MatchSpecsController {

    private final MatchSpecsService matchSpecsService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applySpecs(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody MatchSpecsRequest request
    ) {
        Match match = matchSpecsService.applySpecs(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.service.TossService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/toss")
@RequiredArgsConstructor
public class TossController {

    private final TossService tossService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applyToss(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody TossRequest request
    ) {
        Match match = tossService.applyToss(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class AssignSquadRolesRequest {

    @NotNull
    private Long teamId;

    @NotEmpty
    private List<SquadRoleDTO> roles;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.BallType;
import in.crewplay.crewplay_backend.domain.match.MatchType;
import in.crewplay.crewplay_backend.domain.match.PitchType;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MatchSpecsRequest {

    @NotNull
    private MatchType matchType;

    @NotNull
    private BallType ballType;

    @NotNull
    private PitchType pitchType;

    @NotNull
    @Positive
    private Integer overs;

    private String city; // optional override
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadPlayerDTO {

    @NotNull
    private Long userId;

    private boolean captain;
    private boolean wicketKeeper;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadRoleDTO {

    @NotNull
    private Long userId;

    private boolean captain;

    private boolean wicketKeeper;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class SubmitSquadRequest {

    @NotNull
    private Long teamAId;

    @NotNull
    private Long teamBId;

    @NotEmpty
    private List<SquadPlayerDTO> teamA;

    @NotEmpty
    private List<SquadPlayerDTO> teamB;

    // Optional in Phase-0
    private String city;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.TossDecision;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TossRequest {

    @NotNull
    private Long tossWinnerTeamId;

    @NotNull
    private TossDecision decision;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java">
package in.crewplay.crewplay_backend.domain.match.innings.controller;

import in.crewplay.crewplay_backend.domain.match.innings.dto.InningsContextResponse;
import in.crewplay.crewplay_backend.domain.match.innings.dto.StartInningsRequest;
import in.crewplay.crewplay_backend.domain.match.innings.service.InningsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class InningsController {

    private final InningsService inningsService;

    @GetMapping("/{matchId}/innings/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<InningsContextResponse> getContext(
            @PathVariable Long matchId
    ) {
        return ResponseEntity.ok(
                inningsService.getInningsContext(matchId)
        );
    }

    @PostMapping("/{matchId}/innings/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> startInnings(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody StartInningsRequest request
    ) {
        inningsService.startInnings(matchId, scorerUserId, request);
        return ResponseEntity.ok("Innings started");
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsContextResponse {

    private InningsTeamDTO battingTeam;
    private InningsTeamDTO bowlingTeam;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsPlayerDTO {

    private Long userId;
    private String name;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class InningsTeamDTO {
    private Long teamId;
    private String teamName;
    private String logoUrl;
    private List<InningsPlayerDTO> players;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import in.crewplay.crewplay_backend.domain.match.BattingHand;
import in.crewplay.crewplay_backend.domain.match.BowlingType;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class StartInningsRequest {

    @NotNull
    private Long strikerUserId;

    @NotNull
    private Long nonStrikerUserId;

    @NotNull
    private BattingHand strikerHand;

    @NotNull
    private BattingHand nonStrikerHand;

    @NotNull
    private Long bowlerUserId;

    @NotNull
    private BowlingType bowlingType;


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java">
package in.crewplay.crewplay_backend.domain.match.innings;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_innings")
@Getter
@Setter
public class MatchInnings {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    private int inningsNumber; // 1 or 2

    // üî¢ Score state
    private int totalRuns = 0;
    private int totalWickets = 0;

    private int currentOver = 0;
    private int currentBall = 0; // 0‚Äì5 (valid balls only)

    private int maxOvers; // from match specs

    // üèè Batting state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "striker_id")
    private User striker;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "non_striker_id")
    private User nonStriker;

    // üéØ Bowling state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "current_bowler_id")
    private User currentBowler;

    // Match state
    private boolean completed = false;

    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java">
package in.crewplay.crewplay_backend.domain.match.innings.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface MatchInningsRepository
        extends JpaRepository<MatchInnings, Long> {

    Optional<MatchInnings> findByMatch(Match match);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java">
package in.crewplay.crewplay_backend.domain.match.innings.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.innings.dto.*;
import in.crewplay.crewplay_backend.domain.match.innings.repository.MatchInningsRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class InningsService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadRepository;
    private final MatchInningsRepository matchInningsRepository;
    private final UserRepository userRepository;

    /**
     * STEP 1 ‚Äî Provide players for striker/bowler selection
     */
    public InningsContextResponse getInningsContext(Long matchId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Innings not available yet");
        }

        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found"));

        InningsContextResponse response = new InningsContextResponse();
        response.setBattingTeam(buildTeamDTO(battingTeam));
        response.setBowlingTeam(buildTeamDTO(bowlingTeam));

        return response;
    }

    private InningsTeamDTO buildTeamDTO(MatchTeam matchTeam) {

        InningsTeamDTO dto = new InningsTeamDTO();
        dto.setTeamId(matchTeam.getTeam().getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<InningsPlayerDTO> players = squadRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {
                    InningsPlayerDTO p = new InningsPlayerDTO();
                    p.setUserId(member.getUser().getId());
                    p.setName(member.getUser().getEmail()); // Replace later with real name
                    return p;
                })
                .toList();

        dto.setPlayers(players);
        return dto;
    }

    /**
     * STEP 2 ‚Äî Start innings
     */
    @Transactional
    public void startInnings(
            Long matchId,
            Long scorerUserId,
            StartInningsRequest request
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can start innings");
        }

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Match not ready for innings");
        }

        // 1. Validation for unique selections
        if (request.getStrikerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Striker and non-striker cannot be the same");
        }

        if (request.getBowlerUserId().equals(request.getStrikerUserId()) ||
                request.getBowlerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Bowler cannot be one of the opening batsmen");
        }

// 2. Fetch MatchTeams to validate squads
        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found for this match"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found for this match"));

// 3. Squad Validation using correct DTO getters
        boolean strikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getStrikerUserId());

        boolean nonStrikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getNonStrikerUserId());

        boolean bowlerValid = squadRepository
                .existsByMatchTeamAndUser_Id(bowlingTeam, request.getBowlerUserId());

        if (!strikerValid || !nonStrikerValid) {
            throw new IllegalStateException("Selected batsmen must belong to the batting team squad");
        }

        if (!bowlerValid) {
            throw new IllegalStateException("Selected bowler must belong to the bowling team squad");
        }

// 4. Initialize the Innings
        MatchInnings innings = new MatchInnings();
        innings.setMatch(match);
        innings.setInningsNumber(1);

// Map User entities via References (performance efficient)
        innings.setStriker(userRepository.getReferenceById(request.getStrikerUserId()));
        innings.setNonStriker(userRepository.getReferenceById(request.getNonStrikerUserId()));
        innings.setCurrentBowler(userRepository.getReferenceById(request.getBowlerUserId()));

// Map Hands and Types
        innings.setStrikerHand(request.getStrikerHand());
        innings.setNonStrikerHand(request.getNonStrikerHand());
        innings.setBowlerType(request.getBowlingType()); // Matches DTO field 'bowlingType'

        matchInningsRepository.save(innings);

        match.setStatus(MatchStatus.LIVE);
        matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java">
package in.crewplay.crewplay_backend.domain.match;

import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "match_squad_members",
        uniqueConstraints = @UniqueConstraint(columnNames = {"match_team_id", "user_id"})
)
@Getter
@Setter
public class MatchSquadMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "is_captain", nullable = false)
    private boolean captain = false;

    @Column(name = "is_wicket_keeper", nullable = false)
    private boolean wicketKeeper = false;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java">
    package in.crewplay.crewplay_backend.domain.match;

    import in.crewplay.crewplay_backend.domain.teams.Team;
    import jakarta.persistence.*;
    import lombok.Getter;
    import lombok.Setter;

    @Entity
    @Table(name = "match_teams",
    uniqueConstraints = @UniqueConstraint(columnNames = {"match_id", "side"}))
    @Getter
    @Setter
    public class MatchTeam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    // "A" or "B"
    @Column(nullable = false)
    private String side;
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchType {


    LIMITED_OVERS,
    BOX_CRICKET,
    TEST
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum PitchType {
    GREEN,
    DUSTY,
    HARD,
    MAT
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MatchRepository extends JpaRepository<Match, Long> {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java">
package in.crewplay.crewplay_backend.domain.match.scoring.entity;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.ExtraType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.Id;

import java.time.LocalDateTime;

@Entity
@Table(name = "ball_events")
@Getter
@Setter
public class BallEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "innings_id", nullable = false)
    private MatchInnings innings;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowler_id", nullable = false)
    private User bowler;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "batsman_id", nullable = false)
    private User batsman;

    // Over tracking
    private int overNumber;
    private int ballNumber; // only for valid deliveries

    // Core ball classification
    @Enumerated(EnumType.STRING)
    private BallResultType ballResultType;

    // Runs
    private int runsOffBat = 0;
    private int extraRuns = 0;

    // Extras classification
    @Enumerated(EnumType.STRING)
    private ExtraType extraType;

    // Wicket
    private boolean isWicket = false;

    @Enumerated(EnumType.STRING)
    private WicketType wicketType;

    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum BallResultType {

    NORMAL,      // Valid delivery
    WIDE,
    NO_BALL,
    DEAD_BALL
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum ExtraType {
    WIDE,
    NO_BALL,
    BYE,
    LEG_BYE,
    PENALTY
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum WicketType {
    BOWLED,
    CAUGHT,
    LBW,
    RUN_OUT,
    STUMPED,
    HIT_WICKET,
    OBSTRUCTING_FIELD,
    RETIRED_OUT,
    TIMED_OUT,
    HANDLED_BALL,
    HIT_THE_BALL_TWICE
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.dto.SquadRoleDTO;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MatchRoleService {

    private final MatchSquadMemberRepository squadMemberRepository;

    @Transactional
    public void assignRoles(Long matchId, AssignSquadRolesRequest request) {

        List<MatchSquadMember> squadMembers =
                squadMemberRepository.findByMatchTeam_Match_IdAndMatchTeam_Team_Id(
                        matchId,
                        request.getTeamId()
                );

        if (squadMembers.isEmpty()) {
            throw new IllegalStateException("No squad found for this team in the match");
        }

        Map<Long, MatchSquadMember> squadMap =
                squadMembers.stream()
                        .collect(Collectors.toMap(
                                m -> m.getUser().getId(),
                                Function.identity()
                        ));

        long captainCount =
                request.getRoles().stream()
                        .filter(SquadRoleDTO::isCaptain)
                        .count();

        if (captainCount != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }

        // Reset roles first (idempotent)
        squadMembers.forEach(m -> {
            m.setCaptain(false);
            m.setWicketKeeper(false);
        });

        // Apply new roles
        for (SquadRoleDTO dto : request.getRoles()) {

            MatchSquadMember member = squadMap.get(dto.getUserId());

            if (member == null) {
                throw new IllegalStateException(
                        "User " + dto.getUserId() + " is not part of this squad"
                );
            }

            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
        }

        squadMemberRepository.saveAll(squadMembers);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import in.crewplay.crewplay_backend.domain.match.dto.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.Repository.TeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.lang.System.in;

@Service
@RequiredArgsConstructor
public class MatchService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final TeamRepository teamRepository;
    private final UserRepository userRepository;

    /**
     * üî• SINGLE ENTRY POINT ‚Äî PHASE-0
     * Called when scorer clicks "Start Match"
     */
    @Transactional
    public Match startMatch(Long scorerId, SubmitSquadRequest request) {

        // 1Ô∏è‚É£ VALIDATION (Phase-0 invariants)
        validateSquads(
                request.getTeamA().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamB().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamA().stream().filter(SquadPlayerDTO::isCaptain).count(),
                request.getTeamB().stream().filter(SquadPlayerDTO::isCaptain).count()
        );

        // 2Ô∏è‚É£ CREATE MATCH
        Match match = new Match();
        match.setScorerUserId(scorerId);
        match.setCity(request.getCity()); // optional in Phase-0
        match.setStatus(MatchStatus.READY); // NOT LIVE
        match = matchRepository.save(match);

        // 3Ô∏è‚É£ TEAM A + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamAId(),
                request.getTeamA(),
                "A"
        );

        // 4Ô∏è‚É£ TEAM B + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamBId(),
                request.getTeamB(),
                "B"
        );

        return match;
    }

    /**
     * üîí Phase-0 squad rules
     */
    private void validateSquads(
            List<Long> teamAPlayers,
            List<Long> teamBPlayers,
            long teamACaptains,
            long teamBCaptains
    ) {
        if (teamAPlayers.size() < 3 || teamBPlayers.size() < 3) {
            throw new IllegalStateException("Each team must have at least 3 players");
        }

        Set<Long> intersection = new HashSet<>(teamAPlayers);
        intersection.retainAll(teamBPlayers);

        if (!intersection.isEmpty()) {
            throw new IllegalStateException("Same player cannot play for both teams");
        }

        if (teamACaptains != 1 || teamBCaptains != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }
    }

    /**
     * üß© Helper ‚Äî persists MatchTeam + MatchSquadMembers
     */
    private void saveTeamAndSquad(
            Match match,
            Long teamId,
            List<SquadPlayerDTO> players,
            String side
    ) {
        // Create MatchTeam
        MatchTeam matchTeam = new MatchTeam();
        matchTeam.setMatch(match);
        matchTeam.setTeam(teamRepository.getReferenceById(teamId));
        matchTeam.setSide(side);
        matchTeam = matchTeamRepository.save(matchTeam);

        // Save squad members
        for (SquadPlayerDTO dto : players) {
            MatchSquadMember member = new MatchSquadMember();
            member.setMatchTeam(matchTeam);
            member.setUser(userRepository.getReferenceById(dto.getUserId()));
            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
            squadMemberRepository.save(member);
        }
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MatchSpecsService {

    private final MatchRepository matchRepository;

    @Transactional
    public Match applySpecs(Long scorerUserId, Long matchId, MatchSpecsRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        // üîê Ensure only creator scorer can modify
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("You are not allowed to modify this match");
        }

        // üîí Allow specs only if match is in READY or DRAFT
        if (match.getStatus() != MatchStatus.READY &&
                match.getStatus() != MatchStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify specs after match started");
        }

        // ‚úÖ Apply specs
        match.setMatchType(request.getMatchType());
        match.setBallType(request.getBallType());
        match.setPitchType(request.getPitchType());
        match.setOvers(request.getOvers());

        if (request.getCity() != null && !request.getCity().isBlank()) {
            match.setCity(request.getCity());
        }

        // üîÑ Move status forward
        match.setStatus(MatchStatus.SPECS_LOCKED);

        return matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TossService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;

    @Transactional
    public Match applyToss(Long scorerUserId, Long matchId, TossRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        // üîê Ownership check
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Not allowed");
        }

        // üîí Must be VERIFIED now (NOT SPECS_LOCKED)
        if (match.getStatus() != MatchStatus.VERIFIED) {
            throw new IllegalStateException("Toss allowed only after verification");
        }

        // üîç Fetch match teams
        List<MatchTeam> teams = matchTeamRepository.findByMatch_Id(matchId);
        if (teams.size() != 2) {
            throw new IllegalStateException("Match teams not properly initialized");
        }

        MatchTeam teamA = teams.get(0);
        MatchTeam teamB = teams.get(1);

        boolean validTeam =
                teamA.getTeam().getId().equals(request.getTossWinnerTeamId()) ||
                        teamB.getTeam().getId().equals(request.getTossWinnerTeamId());

        if (!validTeam) {
            throw new IllegalStateException("Invalid toss winner");
        }

        // ü™ô Apply toss
        match.setTossWinnerTeamId(request.getTossWinnerTeamId());
        match.setTossDecision(request.getDecision());

        Long battingTeamId;
        Long bowlingTeamId;

        if (request.getDecision() == TossDecision.BAT) {
            battingTeamId = request.getTossWinnerTeamId();
        } else {
            battingTeamId =
                    teamA.getTeam().getId().equals(request.getTossWinnerTeamId())
                            ? teamB.getTeam().getId()
                            : teamA.getTeam().getId();
        }

        bowlingTeamId =
                teamA.getTeam().getId().equals(battingTeamId)
                        ? teamB.getTeam().getId()
                        : teamA.getTeam().getId();

        match.setBattingTeamId(battingTeamId);
        match.setBowlingTeamId(bowlingTeamId);

        // üö¶ IMPORTANT: Move to TOSS_DONE (NOT LIVE)
        match.setStatus(MatchStatus.TOSS_DONE);

        return matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java">
package in.crewplay.crewplay_backend.domain.match;

public enum TossDecision {

    BAT,
    BOWL

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java">
package in.crewplay.crewplay_backend.domain.match.verification.controller;

import in.crewplay.crewplay_backend.domain.match.verification.dto.VerificationContextResponse;
import in.crewplay.crewplay_backend.domain.match.verification.service.MatchVerificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchVerificationController {

    private final MatchVerificationService verificationService;

    @GetMapping("/{matchId}/verification/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<VerificationContextResponse> getContext(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId
    ) {

        return ResponseEntity.ok(
                verificationService.getVerificationContext(matchId, scorerUserId)
        );
    }

    @PostMapping("/{matchId}/verification/send")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> sendVerification(
            @PathVariable Long matchId,
            @RequestParam Long matchTeamId,
            @RequestParam Long selectedUserId,
            @RequestAttribute("userId") Long scorerUserId
    ) {
        verificationService.sendVerificationRequest(
                scorerUserId,
                matchId,
                matchTeamId,
                selectedUserId
        );
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/accept")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> accept(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.acceptVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/reject")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> reject(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.rejectVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationContextResponse {

    private VerificationTeamDTO teamA;
    private VerificationTeamDTO teamB;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationPlayerDTO {

    private Long userId;
    private String name;
    private boolean isGuest;
    private boolean isScorer;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class VerificationTeamDTO {

    private Long matchTeamId;
    private String teamName;
    private String logoUrl;
    private List<VerificationPlayerDTO> players;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java">
package in.crewplay.crewplay_backend.domain.match.verification;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_verifications")
@Getter
@Setter
public class MatchVerification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Which match
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    // Team side (A / B)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    // Selected verifier (must be registered user)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "verifier_user_id", nullable = false)
    private User verifier;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MatchVerificationStatus status = MatchVerificationStatus.PENDING;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "responded_at")
    private LocalDateTime respondedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java">
package in.crewplay.crewplay_backend.domain.match.verification;

public enum MatchVerificationStatus {
    PENDING,
    VERIFIED,
    REJECTED
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java">
package in.crewplay.crewplay_backend.domain.match.verification.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchVerificationRepository extends JpaRepository<MatchVerification, Long> {

    Optional<MatchVerification> findByMatchAndMatchTeam(Match match, MatchTeam matchTeam);

    List<MatchVerification> findByMatch(Match match);

    boolean existsByMatchAndStatus(Match match, MatchVerificationStatus status);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java">
package in.crewplay.crewplay_backend.domain.match.verification.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import in.crewplay.crewplay_backend.domain.match.verification.dto.*;
import in.crewplay.crewplay_backend.domain.match.verification.repository.MatchVerificationRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class MatchVerificationService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final MatchVerificationRepository matchVerificationRepository;
    private final UserRepository userRepository;

    public VerificationContextResponse getVerificationContext(Long matchId, Long scorerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not ready for verification");
        }

        List<MatchTeam> matchTeams = matchTeamRepository.findByMatch(match);

        MatchTeam teamA = matchTeams.stream()
                .filter(mt -> "A".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team A not found"));

        MatchTeam teamB = matchTeams.stream()
                .filter(mt -> "B".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team B not found"));

        VerificationContextResponse response = new VerificationContextResponse();
        response.setTeamA(buildTeamDTO(teamA, scorerUserId));
        response.setTeamB(buildTeamDTO(teamB, scorerUserId));

        return response;
    }

    private VerificationTeamDTO buildTeamDTO(MatchTeam matchTeam, Long scorerUserId) {

        VerificationTeamDTO dto = new VerificationTeamDTO();
        dto.setMatchTeamId(matchTeam.getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<VerificationPlayerDTO> players = squadMemberRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {

                    VerificationPlayerDTO playerDTO = new VerificationPlayerDTO();
                    playerDTO.setUserId(member.getUser().getId());
                    playerDTO.setName(member.getUser().getEmail()); // or better name if available
                    playerDTO.setGuest(false); // squad only contains registered users
                    playerDTO.setScorer(member.getUser().getId().equals(scorerUserId));

                    return playerDTO;
                })
                .toList();

        dto.setPlayers(players);

        return dto;
    }

    @Transactional
    public void sendVerificationRequest(
            Long scorerUserId,
            Long matchId,
            Long matchTeamId,
            Long selectedUserId
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not in verification stage");
        }

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can send verification");
        }

        if (scorerUserId.equals(selectedUserId)) {
            throw new IllegalStateException("Scorer cannot verify his own match");
        }

        MatchTeam matchTeam = matchTeamRepository.findById(matchTeamId)
                .orElseThrow(() -> new RuntimeException("Match team not found"));

        // Ensure player is in squad
        boolean inSquad = squadMemberRepository.findByMatchTeam(matchTeam)
                .stream()
                .anyMatch(member -> member.getUser().getId().equals(selectedUserId));

        if (!inSquad) {
            throw new IllegalStateException("Selected player not in squad");
        }

        // Prevent duplicate request per team
        if (matchVerificationRepository.findByMatchAndMatchTeam(match, matchTeam).isPresent()) {
            throw new IllegalStateException("Verification already sent for this team");
        }

        MatchVerification verification = new MatchVerification();
        verification.setMatch(match);
        verification.setMatchTeam(matchTeam);
        verification.setVerifier(
                userRepository.getReferenceById(selectedUserId)
        );
        verification.setStatus(MatchVerificationStatus.PENDING);

        matchVerificationRepository.save(verification);
    }

    @Transactional
    public void acceptVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.VERIFIED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        checkAndPromoteMatch(match);
    }

    @Transactional
    public void rejectVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.REJECTED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        match.setStatus(MatchStatus.DRAFT); // rollback stage
        matchRepository.save(match);
    }

    private void checkAndPromoteMatch(Match match) {

        boolean hasPending = matchVerificationRepository
                .existsByMatchAndStatus(match, MatchVerificationStatus.PENDING);

        if (!hasPending) {
            match.setStatus(MatchStatus.VERIFIED);
            matchRepository.save(match);
        }
    }



}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/enums/TeamStatus.java">
    package in.crewplay.crewplay_backend.domain.teams.enums;

    public enum TeamStatus {

    TEMPORARY, // Created inside match flow
    ACTIVE, // Permanent team
    ARCHIVED
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java">
package in.crewplay.crewplay_backend.domain.user;

public enum ExperienceLevel {
    BEGINNER,
    INTERMEDIATE,
    ADVANCED,
    PROFESSIONAL

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Gender {
    MALE,
    FEMALE,
    OTHER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java">
package in.crewplay.crewplay_backend.domain.user;

public enum PlayingRole {
    WICKET_KEEPER,
    OPENING_BATSMAN,
    MIDDLE_ORDER_BATSMAN,
    LOWER_ORDER_BATSMAN,
    ALL_ROUNDER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Role {
    PLAYER,
    SCORER,
    TEAM_MANAGER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/User.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "mobile_number", nullable = false, unique = true)
    private String mobileNumber;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "is_active")
    private Boolean isActive = true;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_follows",
        uniqueConstraints = @UniqueConstraint(
                columnNames = {"follower_user_id", "following_user_id"}
        )
)
@Getter
@Setter
public class UserFollow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "follower_user_id", nullable = false)
    private User follower;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "following_user_id", nullable = false)
    private User following;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java">
package in.crewplay.crewplay_backend.match_setup.Controller;

public class MatchSetupController {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class CreateQuickMatchRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectSquadRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectTeamRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java">
package in.crewplay.crewplay_backend.match_setup.dto.response;

public class MatchSetupResponse {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchRepository {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchSquadRepository {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java">
package in.crewplay.crewplay_backend.match_setup.Service;

public class MatchSetupService {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java">
package in.crewplay.crewplay_backend.Scorer.Controller;

import in.crewplay.crewplay_backend.Scorer.Service.ScorerService;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/scorer")
@RequiredArgsConstructor
public class ScorerController {

    private final ScorerService scorerService;

    @GetMapping("/me")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<ScorerProfile> getMyScorerProfile(
            @RequestAttribute("userId") Long userId
    ) {
        ScorerProfile profile = scorerService.getOrCreateScorerProfile(userId);
        return ResponseEntity.ok(profile);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java">
package in.crewplay.crewplay_backend.Scorer.Repository;

import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ScorerProfileRepository extends JpaRepository<ScorerProfile, Long> {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java">
package in.crewplay.crewplay_backend.Scorer.Service;

import in.crewplay.crewplay_backend.Scorer.Repository.ScorerProfileRepository;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class ScorerService {

    private final ScorerProfileRepository scorerProfileRepository;
    private final UserRepository userRepository;

    public ScorerProfile getOrCreateScorerProfile(Long userId) {

        return scorerProfileRepository.findById(userId)
                .orElseGet(() -> {
                    User user = userRepository.findById(userId)
                            .orElseThrow(() -> new RuntimeException("User not found"));

                    ScorerProfile scorerProfile = new ScorerProfile();
                    scorerProfile.setId(userId);
                    scorerProfile.setUser(user);

                    // Auto-copy from User
                    scorerProfile.setEmail(user.getEmail());
                    scorerProfile.setMobileNumber(user.getMobileNumber());
                    scorerProfile.setName(extractNameFromEmail(user.getEmail()));

                    scorerProfile.setMemberSince(LocalDateTime.now());
                    scorerProfile.setCreatedAt(LocalDateTime.now());

                    return scorerProfileRepository.save(scorerProfile);
                });
    }

    private String extractNameFromEmail(String email) {
        return email.split("@")[0];
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Controller/TeamRosterController.java">
package in.crewplay.crewplay_backend.team_roster.Controller;

public class TeamRosterController {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddGuestPlayerRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddPlayerByMobileRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java">
package in.crewplay.crewplay_backend.team_roster.dto.response;

public class TeamMemberResponse {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Service/TeamRosterService.java">
package in.crewplay.crewplay_backend.team_roster.Service;

public class TeamRosterService {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java">
package in.crewplay.crewplay_backend.team.dto.response;

public class TeamResponse {
}
</file>

<file path="src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java">
package in.crewplay.crewplay_backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CrewplayBackendApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java">
package in.crewplay.crewplay_backend.Auth.filter;


import in.crewplay.crewplay_backend.Auth.util.JwtTokenParser;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenParser tokenParser;

    public JwtAuthenticationFilter(JwtTokenParser tokenParser) {
        this.tokenParser = tokenParser;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return request.getRequestURI().startsWith("/auth/");
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(7);

        if (!tokenParser.validateToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        Long userId = tokenParser.extractUserId(token);
        List<String> roles = tokenParser.extractRoles(token);
        String activeRole = tokenParser.extractActiveRole(token);

        List<SimpleGrantedAuthority> authorities =
                roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userId,
                        null,
                        authorities
                );

        authentication.setDetails(
                new WebAuthenticationDetailsSource().buildDetails(request)
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);

        // üîë CRITICAL FOR CONTROLLERS
        request.setAttribute("userId", userId);
        request.setAttribute("active_role", activeRole);

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java">
package in.crewplay.crewplay_backend.common.enums;

public enum PlayerAddMethod {
    MOBILE_NUMBER,
    TEAM_CODE,
    MANUAL_GUEST
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java">
package in.crewplay.crewplay_backend.config;


import in.crewplay.crewplay_backend.Auth.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity // ‚úÖ REQUIRED for @PreAuthorize
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http
                .csrf(csrf -> csrf.disable())
                .formLogin(form -> form.disable())
                .httpBasic(basic -> basic.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .anyRequest().authenticated()
                );

        http.addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
        );

        return http.build();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchStatus {


    DRAFT,                   // Squads not finalized
    READY,                   // Squads finalized
    SPECS_LOCKED,            // Match specs saved
    AWAITING_VERIFICATION,   // Waiting for team confirmations
    VERIFIED,                // Both teams confirmed
    TOSS_DONE,               // Toss completed
    LIVE,                    // Innings started
    COMPLETED                // Match finished

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchSquadMemberRepository extends JpaRepository<MatchSquadMember, Long> {
    List<MatchSquadMember> findByMatchTeam(MatchTeam matchTeam);

    List<MatchSquadMember>
    findByMatchTeam_Match_IdAndMatchTeam_Team_Id(Long matchId, Long teamId);
    boolean existsByMatchTeam_Match_IdAndMatchTeam_Team_IdAndUser_Id(
            Long matchId,
            Long teamId,
            Long userId
    );


    boolean existsByMatchTeamAndUser_Id(MatchTeam matchTeam, Long userId);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchTeamRepository extends JpaRepository<MatchTeam, Long> {
    List<MatchTeam> findByMatch(Match match);
    List<MatchTeam> findByMatch_Id(Long matchId);

    Optional<MatchTeam> findByMatch_IdAndTeam_Id(Long matchId, Long teamId);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/TeamMember.java">
package in.crewplay.crewplay_backend.domain.team;

import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "team_members",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"team_id", "user_id"})
        }
)
@Getter
@Setter
public class TeamMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- RELATIONS ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    /**
     * Can be NULL for guest players
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    // ---------- PLAYER INFO ----------

    @Column(name = "display_name", nullable = false)
    private String displayName;

    @Column(name = "mobile_number", nullable = false)
    private String mobileNumber;

    @Column(name = "is_guest", nullable = false)
    private Boolean isGuest = false;

    // ---------- HOW THEY WERE ADDED ----------

    @Enumerated(EnumType.STRING)
    @Column(name = "add_method", nullable = false)
    private PlayerAddMethod addMethod;

    @Column(name = "added_by_scorer_id", nullable = false)
    private Long addedByScorerId;

    // ---------- TRUST / REPORTING (PHASE-1 READY) ----------

    @Column(name = "reported", nullable = false)
    private Boolean reported = false;

    // ---------- SYSTEM ----------

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_profiles")
@Getter
@Setter
public class PlayerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Enumerated(EnumType.STRING)
    private Gender gender;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // CRICKET INFO
    @Enumerated(EnumType.STRING)
    @Column(name = "playing_role")
    private PlayingRole playingRole;

    private String battingStyle;
    private String bowlingStyle;

    @Enumerated(EnumType.STRING)
    @Column(name = "experience_level")
    private ExperienceLevel experienceLevel;

    // LOCATION
    private String city;

    // MEDIA
    @Column(name = "profile_image_url")
    private String profileImageUrl;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SYSTEM
    @Column(name = "is_profile_complete")
    private Boolean isProfileComplete = false;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository; // Ensure this matches your folder

import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    // This allows .findByEmail() to work in AuthController
    Optional<User> findByEmail(String email);
    Optional<User> findByMobileNumber(String mobileNumber);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository;

import in.crewplay.crewplay_backend.domain.user.UserRole;
import in.crewplay.crewplay_backend.domain.user.Role;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserRoleRepository extends JpaRepository<UserRole, Long> {

    List<UserRole> findByUserId(Long userId);

    Optional<UserRole> findByUserIdAndRole(Long userId, Role role);

    Optional<UserRole> findByUserIdAndIsActiveTrue(Long userId);


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "team_manager_profiles")
@Getter
@Setter
public class TeamManagerProfile {

    @Id
    private Long id; // SAME AS users.id

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // TEAM MANAGEMENT META
    @Column(name = "teams_handled_count")
    private Long teamsHandledCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_roles",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "role"})
)
@Getter
@Setter
public class UserRole {

    @Id // Corrected Import: jakarta.persistence.Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private Boolean isActive = false; // Added this for your logic to work!

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Repository/TeamMemberRepository.java">
package in.crewplay.crewplay_backend.team_roster.repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.TeamMember;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamMemberRepository extends JpaRepository<TeamMember, Long> {

    Optional<TeamMember> findByTeamAndUser(Team team, User user);

    List<TeamMember> findByTeam(Team team);

    List<TeamMember> findByTeam_Id(Long teamId);

    boolean existsByTeam_IdAndUser_Id(Long teamId, Long userId);


    boolean existsByTeamAndUser(Team team, User user);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java">
package in.crewplay.crewplay_backend.team.Controller;


import in.crewplay.crewplay_backend.team.Service.TeamService;
import in.crewplay.crewplay_backend.team.dto.request.CreateTeamRequest;
import in.crewplay.crewplay_backend.team.dto.request.VerifyCaptainRequest;
import in.crewplay.crewplay_backend.domain.teams.Team;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/teams")
@RequiredArgsConstructor
public class TeamController {

    private final TeamService teamService;

    /**
     * STEP 1 ‚Äî Send captain verification OTP (EMAIL)
     */
    @PostMapping("/verify-captain")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<String> verifyCaptain(
            @RequestBody VerifyCaptainRequest request
    ) {
        teamService.sendCaptainVerificationOtp(request.getCaptainEmail());
        return ResponseEntity.ok("OTP sent to captain email");
    }

    /**
     * STEP 2 ‚Äî Create team (OTP already verified on frontend)
     */
    @PostMapping("/create")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Team> createTeam(
            @RequestAttribute("userId") Long scorerUserId,
            @RequestBody CreateTeamRequest request
    ) {
        Team team = teamService.createTeam(
                scorerUserId,
                request.getTeamName(),
                request.getCity(),
                request.getLogoUrl(),
                request.getCaptainMobileNumber()
        );
        return ResponseEntity.ok(team);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CreateTeamRequest {

    private String teamName;
    private String city;
    private String logoUrl;
    private String captainMobileNumber;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyCaptainRequest {
    private String captainEmail;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java">
package in.crewplay.crewplay_backend.team.util;

import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class TeamCodeGenerator {

    public String generate() {
        return UUID.randomUUID()
                .toString()
                .substring(0, 8)
                .toUpperCase();
    }
}
</file>

<file path="src/main/resources/application.yaml">
server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/crewplay
    username: crewplay
    password: crewplay
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    open-in-view: false

  redis:
    host: localhost
    port: 6379

  mail:
    host: smtp.gmail.com
    port: 587
    username: your_email@gmail.com
    password: your_app_password
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

jwt:
  # This secret MUST be at least 32 characters for HS256
  secret: crewplay-super-secret-key-must-be-long-enough-32chars
  expiration: 86400000 # 1 day
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java">
package in.crewplay.crewplay_backend.domain.match;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDateTime;

@Entity
@Table(name = "matches")
@Getter
@Setter
public class Match {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "scorer_user_id", nullable = false)
    private Long scorerUserId;

    @Enumerated(EnumType.STRING)
    private MatchStatus status = MatchStatus.DRAFT;

    private String city;

    // üîπ MATCH SPECS
    @Enumerated(EnumType.STRING)
    @Column(name = "match_type")
    private MatchType matchType;

    @Enumerated(EnumType.STRING)
    @Column(name = "ball_type")
    private BallType ballType;

    @Enumerated(EnumType.STRING)
    @Column(name = "pitch_type")
    private PitchType pitchType;

    private Integer overs;

    // üîπ TOSS INFO
    @Column(name = "toss_winner_team_id")
    private Long tossWinnerTeamId;

    @Enumerated(EnumType.STRING)
    @Column(name = "toss_decision")
    private TossDecision tossDecision; // Only one declaration now

    // üîπ LIVE GAME STATE
    @Column(name = "batting_team_id")
    private Long battingTeamId;

    @Column(name = "bowling_team_id")
    private Long bowlingTeamId;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/Team.java">
    package in.crewplay.crewplay_backend.domain.team;

    import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
    import in.crewplay.crewplay_backend.domain.user.User;
    import jakarta.persistence.*;
    import lombok.Getter;
    import lombok.Setter;

    import java.time.LocalDateTime;

    @Entity
    @Table(
    name = "teams",
    uniqueConstraints = {
    @UniqueConstraint(columnNames = "team_code"),
    @UniqueConstraint(columnNames = {"name", "city"})
    }
    )
    @Getter
    @Setter
    public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- BASIC INFO ----------

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String city;

    @Column(name = "logo_url")
    private String logoUrl;

    // ---------- TEAM CODE (JOINING / QR / LINK) ----------

    @Column(name = "team_code", nullable = false, unique = true)
    private String teamCode;

    // ---------- CAPTAIN & OWNERSHIP ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "captain_user_id", nullable = false)
    private User captain;


    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TeamStatus status = TeamStatus.TEMPORARY;

    // ---------- TRUST / VERIFICATION ----------

    @Column(name = "is_verified", nullable = false)
    private Boolean isVerified = false; // Phase-0 always false

    @Column(name = "verification_method")
    private String verificationMethod; // EMAIL (Phase-0)

    @Column(name = "verified_at")
    private LocalDateTime verifiedAt;

    // ---------- SYSTEM ----------

    @Column(name = "created_by_scorer_id", nullable = false)
    private Long createdByScorerId;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "scorer_profiles")
@Getter
@Setter
public class ScorerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SCORER TRUST SIGNAL
    @Column(name = "unverified_matches_count")
    private Long unverifiedMatchesCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    private Integer matchesScored = 0;
    private Double accuracy = 100.0;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Repository/TeamRepository.java">
package in.crewplay.crewplay_backend.team.Repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamRepository extends JpaRepository<Team, Long> {

    Optional<Team> findByTeamCode(String teamCode);

    List<Team> findByCreatedByScorerId(Long scorerId);

    boolean existsByNameAndCity(String name, String city);

    List<Team> findByCaptainAndStatus(User captain, TeamStatus status);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java">
    package in.crewplay.crewplay_backend.team.Service;

    import in.crewplay.crewplay_backend.Auth.service.OtpService;
    import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
    import in.crewplay.crewplay_backend.domain.teams.Team;
    import in.crewplay.crewplay_backend.domain.teams.TeamMember;
    import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
    import in.crewplay.crewplay_backend.domain.user.User;
    import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
    import in.crewplay.crewplay_backend.team.Repository.TeamRepository;
    import in.crewplay.crewplay_backend.team.util.TeamCodeGenerator;
    import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
    import lombok.RequiredArgsConstructor;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.time.LocalDateTime;

    @Service
    @RequiredArgsConstructor
    public class TeamService {

    private final TeamRepository teamRepository;
    private final UserRepository userRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final OtpService otpService;
    private final TeamCodeGenerator teamCodeGenerator;

    /**
    * STEP 1 ‚Äî Send captain verification OTP (EMAIL)
    */
    public void sendCaptainVerificationOtp(String captainEmail) {
    otpService.generateAndStoreOtp(captainEmail);
    }

    /**
    * STEP 2 ‚Äî Create Team (OTP already verified)
    *
    * IMPORTANT:
    * - Team is created as TEMPORARY
    * - TEAM_MANAGER role is NOT assigned here
    * - Ownership will be granted after match completion
    */
    @Transactional
    public Team createTeam(
    Long scorerUserId,
    String teamName,
    String city,
    String logoUrl,
    String captainMobileNumber
    ) {

    // 1Ô∏è‚É£ Prevent duplicate team in same city
    if (teamRepository.existsByNameAndCity(teamName, city)) {
    throw new RuntimeException("Team already exists in this city");
    }

    // 2Ô∏è‚É£ Captain must be an existing user
    User captain = userRepository.findByMobileNumber(captainMobileNumber)
    .orElseThrow(() -> new RuntimeException("Captain must be an existing user"));

    // 3Ô∏è‚É£ Generate team code
    String teamCode = teamCodeGenerator.generate();

    // 4Ô∏è‚É£ Create TEMPORARY team
    Team team = new Team();
    team.setName(teamName);
    team.setCity(city);
    team.setLogoUrl(logoUrl);
    team.setTeamCode(teamCode);
    team.setCaptain(captain);
    team.setCreatedByScorerId(scorerUserId);
    team.setVerificationMethod("EMAIL");
    team.setStatus(TeamStatus.TEMPORARY); // üî• CRITICAL CHANGE
    team.setCreatedAt(LocalDateTime.now());

    Team savedTeam = teamRepository.save(team);

    // 5Ô∏è‚É£ Add captain to roster
    TeamMember captainMember = new TeamMember();
    captainMember.setTeam(savedTeam);
    captainMember.setUser(captain);
    captainMember.setDisplayName(extractDisplayName(captain));
    captainMember.setMobileNumber(captainMobileNumber);
    captainMember.setAddMethod(PlayerAddMethod.TEAM_CODE);
    captainMember.setIsGuest(false);
    captainMember.setReported(false);
    captainMember.setAddedByScorerId(scorerUserId);
    captainMember.setCreatedAt(LocalDateTime.now());

    teamMemberRepository.save(captainMember);

    // ‚ùå REMOVED:
    // assignTeamManagerRoleIfMissing(captain);

    return savedTeam;
    }

    /**
    * Fallback display name logic (Phase-0 safe)
    */
    private String extractDisplayName(User user) {
    if (user.getEmail() != null) {
    return user.getEmail().split("@")[0];
    }
    return user.getMobileNumber();
    }
    }
</file>

</files>
