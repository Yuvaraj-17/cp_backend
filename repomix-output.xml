This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
my-backend-main/.gitattributes
my-backend-main/.gitignore
my-backend-main/mvnw
my-backend-main/mvnw.cmd
my-backend-main/pom.xml
my-backend-main/README.md
my-backend-main/repomix-output.xml
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/InningsStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/controller/ScoringController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/BowlerScore.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/BowlerSelectionDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/EndOverResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/LiveScoreResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/PlayerScore.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/PlayerSelectionDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/ScoreBallRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/ScoreBallResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/WicketRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/FallOfWicket.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/WicketDetails.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/repository/BallEventRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/repository/FallOfWicketRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/service/ScoringService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/AvailabilityStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/JoinRequestStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/JoinRequestType.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/TeamStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/PlayerAvailability.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/repository/JoinRequestStatus.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/repository/TeamPlayerRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/Team.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamJoinRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamMember.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamPlayer.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/User.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerAnalyticsController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerApprovalController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerDashboardController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerRecruitController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerRosterController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerSquadController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerTeamController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/TeamManagerProfileController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/AddGuestRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/ConfirmPlayingXiRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/CreateTeamManagerRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/InvitePlayerRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateAvailabilityRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateManagerProfileRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateTeamRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/ApprovalsOverviewResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/FullTeamStatsResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/MatchAnalyticsResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PendingApprovalResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PlayerProfileStatsResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PlayerStatRow.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/RosterPlayerResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/SquadManagementResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/SquadPlayerCard.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamAnalyticsResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamManagerProfileResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamSummaryResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TopContributorResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Repository/TeamManagerProfileRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerAnalyticsService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerApprovalService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerDashboardService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerRecruitService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerRosterService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerSquadService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerTeamService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/TeamManagerProfileService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/controller/TeamRosterController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/repository/TeamMemberRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/service/TeamRosterService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/AvailabilityStatusForOverAllTeam.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/JoinRequestStatusForOverAllTeam.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/JoinRequestTypeForOverAllTeam.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/TeamStatusForOverAllTeam.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/PlayerAvailabilityRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamJoinRequestRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamPlayerRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamRepository.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java
my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java
my-backend-main/src/main/resources/application.yaml
my-backend-main/src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="my-backend-main/.gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path="my-backend-main/.gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="my-backend-main/mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="my-backend-main/mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="my-backend-main/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.10</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>in.crewplay</groupId>
	<artifactId>crewplay-backend</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>crewplay-backend</name>
	<description>Demo project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<!-- JWT -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>

		<!-- Mail -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
</file>

<file path="my-backend-main/README.md">
# my-backend
</file>

<file path="my-backend-main/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
mvnw
mvnw.cmd
pom.xml
src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java
src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java
src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java
src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java
src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java
src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java
src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java
src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java
src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java
src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java
src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java
src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java
src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java
src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java
src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java
src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java
src/main/java/in/crewplay/crewplay_backend/domain/team/enums/TeamStatus.java
src/main/java/in/crewplay/crewplay_backend/domain/team/Team.java
src/main/java/in/crewplay/crewplay_backend/domain/team/TeamMember.java
src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java
src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java
src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java
src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java
src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java
src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java
src/main/java/in/crewplay/crewplay_backend/domain/user/User.java
src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java
src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java
src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java
src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java
src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Controller/TeamRosterController.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java
src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Repository/TeamMemberRepository.java
src/main/java/in/crewplay/crewplay_backend/team_roster/Service/TeamRosterService.java
src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java
src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java
src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java
src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java
src/main/java/in/crewplay/crewplay_backend/team/Repository/TeamRepository.java
src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java
src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java
src/main/resources/application.yaml
src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

scriptDir="$(dirname "$0")"
scriptName="$(basename "$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" ]; then
  if [ -f "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/bin/$MVN_CMD" ]; then
    actualDistributionDir="$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "$dir" ]; then
      if [ -f "$dir/bin/$MVN_CMD" ]; then
        actualDistributionDir="$(basename "$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "$actualDistributionDir" ]; then
  verbose "Contents of $TMP_DOWNLOAD_DIR:"
  verbose "$(ls -la "$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: $actualDistributionDir"
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$actualDistributionDir/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$actualDistributionDir" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND -eq $False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace "^.*$MVNW_REPO_PATTERN",'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''

$MAVEN_M2_PATH = "$HOME/.m2"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_M2_PATH = "$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path $MAVEN_M2_PATH)) {
    New-Item -Path $MAVEN_M2_PATH -ItemType Directory | Out-Null
}

$MAVEN_WRAPPER_DISTS = $null
if ((Get-Item $MAVEN_M2_PATH).Target[0] -eq $null) {
  $MAVEN_WRAPPER_DISTS = "$MAVEN_M2_PATH/wrapper/dists"
} else {
  $MAVEN_WRAPPER_DISTS = (Get-Item $MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

$MAVEN_HOME_PARENT = "$MAVEN_WRAPPER_DISTS/$distributionUrlNameMain"
$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
$expectedPath = Join-Path "$TMP_DOWNLOAD_DIR" "$distributionUrlNameMain"
$expectedMvnPath = Join-Path "$expectedPath" "bin/$MVN_CMD"
if ((Test-Path -Path $expectedPath -PathType Container) -and (Test-Path -Path $expectedMvnPath -PathType Leaf)) {
  $actualDistributionDir = $distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!$actualDistributionDir) {
  Get-ChildItem -Path "$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    $testPath = Join-Path $_.FullName "bin/$MVN_CMD"
    if (Test-Path -Path $testPath -PathType Leaf) {
      $actualDistributionDir = $_.Name
    }
  }
}

if (!$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: $actualDistributionDir"
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$actualDistributionDir" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.10</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>in.crewplay</groupId>
	<artifactId>crewplay-backend</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>crewplay-backend</name>
	<description>Demo project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<!-- JWT -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
			<scope>runtime</scope>
		</dependency>

		<!-- Mail -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java">
package in.crewplay.crewplay_backend.Auth.Controller;


import in.crewplay.crewplay_backend.Auth.DTO.Request.RequestOtpRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.StartJourneyRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.VerifyOtpRequest;
import in.crewplay.crewplay_backend.Auth.service.EmailService;
import in.crewplay.crewplay_backend.Auth.util.JwtUtil;
import in.crewplay.crewplay_backend.Auth.service.OtpService;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRoleRepository;
import in.crewplay.crewplay_backend.domain.user.Role;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.UserRole;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/auth")
public class AuthController {

    private final OtpService otpService;
    private final EmailService emailService;
    private final UserRepository userRepository;
    private final UserRoleRepository userRoleRepository;
    private final JwtUtil jwtUtil;

    public AuthController(
            OtpService otpService,
            EmailService emailService,
            UserRepository userRepository,
            UserRoleRepository userRoleRepository,
            JwtUtil jwtUtil
    ) {
        this.otpService = otpService;
        this.emailService = emailService;
        this.userRepository = userRepository;
        this.userRoleRepository = userRoleRepository;
        this.jwtUtil = jwtUtil;
    }

    /**
     * STEP 1  REQUEST OTP (Signup + Login)
     */
    @PostMapping("/request-otp")
    public void requestOtp(@Valid @RequestBody RequestOtpRequest request) {
        String otp = otpService.generateAndStoreOtp(request.getEmail());
        emailService.sendOtpEmail(request.getEmail(), otp);
    }

    /**
     * STEP 2  VERIFY OTP (Identity Proven)
     */
    @PostMapping("/verify-otp")
    public Long verifyOtp(@Valid @RequestBody VerifyOtpRequest request) {

        boolean valid = otpService.verifyOtp(request.getEmail(), request.getOtp());
        if (!valid) {
            throw new RuntimeException("Invalid or expired OTP");
        }

        User user = userRepository.findByEmail(request.getEmail())
                .orElseGet(() -> {
                    User newUser = new User();
                    newUser.setEmail(request.getEmail());
                    return userRepository.save(newUser);
                });

        // Frontend only needs userId at this stage
        return user.getId();
    }

    /**
     * STEP 3  START JOURNEY (ONE ACTIVE ROLE GUARANTEED)
     */
    @PostMapping("/start-journey/{userId}")
    public String startJourney(
            @PathVariable Long userId,
            @Valid @RequestBody StartJourneyRequest request
    ) {
        Role selectedRole = request.getRole();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // 1 Deactivate ALL existing roles
        List<UserRole> existingRoles = userRoleRepository.findByUserId(userId);
        existingRoles.forEach(ur -> ur.setIsActive(false));
        userRoleRepository.saveAll(existingRoles);

        // 2 Activate or create the selected role
        UserRole currentRole = userRoleRepository
                .findByUserIdAndRole(userId, selectedRole)
                .orElseGet(() -> {
                    UserRole ur = new UserRole();
                    ur.setUser(user);
                    ur.setRole(selectedRole);
                    return ur;
                });

        currentRole.setIsActive(true);
        userRoleRepository.save(currentRole);

        // 3 Collect ALL roles owned by user (for JWT)
        List<String> roleNames = userRoleRepository.findByUserId(userId)
                .stream()
                .map(ur -> ur.getRole().name())
                .toList();

        // 4 Issue JWT with ACTIVE ROLE
        return jwtUtil.generateToken(
                userId,
                roleNames,
                selectedRole.name()
        );
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RequestOtpRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import in.crewplay.crewplay_backend.domain.user.Role;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class StartJourneyRequest {

    @NotNull(message = "Role must be selected")
    private Role role;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyOtpRequest {

    @NotBlank
    @Email
    private String email;

    @NotBlank(message = "OTP is required")
    private String otp;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailService {

    private final JavaMailSender mailSender;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendOtpEmail(String to, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject("CrewPlay Login OTP");
        message.setText("Your OTP is: " + otp + "\nValid for 5 minutes.");
        mailSender.send(message);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Random;

@Service
public class OtpService {

    private final StringRedisTemplate redisTemplate;
    private static final int OTP_TTL_MINUTES = 5;

    public OtpService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public String generateAndStoreOtp(String email) {
        String otp = String.valueOf(100000 + new Random().nextInt(900000));
        redisTemplate.opsForValue()
                .set("otp:" + email, otp, Duration.ofMinutes(OTP_TTL_MINUTES));
        return otp;
    }

    public boolean verifyOtp(String email, String otp) {
        String key = "otp:" + email;
        String storedOtp = redisTemplate.opsForValue().get(key);

        if (storedOtp != null && storedOtp.equals(otp)) {
            redisTemplate.delete(key); // one-time use
            return true;
        }
        return false;
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.List;

@Component
public class JwtTokenParser {

    @Value("${jwt.secret}")
    private String secret;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    //  VALIDATE TOKEN SAFELY
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException |
                 MalformedJwtException |
                 ExpiredJwtException |
                 IllegalArgumentException e) {

            // In real prod  use logger
            System.out.println("Invalid JWT: " + e.getMessage());
            return false;
        }
    }

    private Claims getAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public Long extractUserId(String token) {
        return Long.parseLong(getAllClaims(token).getSubject());
    }

    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        return (List<String>) getAllClaims(token).get("roles");
    }

    public String extractActiveRole(String token) {
        return (String) getAllClaims(token).get("active_role");
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Long userId, List<String> roles, String activeRole) {
        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .claim("roles", roles)
                .claim("active_role", activeRole)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java">
package in.crewplay.crewplay_backend.common.enums;

public class MatchStatus {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java">
package in.crewplay.crewplay_backend.common.enums;

public class PlayingRole {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java">
package in.crewplay.crewplay_backend.common.enums;

public class TeamVisibility {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java">
package in.crewplay.crewplay_backend.common;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationErrors(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors()
                .forEach(err -> errors.put(err.getField(), err.getDefaultMessage()));

        return ResponseEntity.badRequest().body(errors);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java">
package in.crewplay.crewplay_backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CrewplayBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(CrewplayBackendApplication.class, args);
	}




}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BallType {
    TENNIS,
    LEATHER,
    CORK,
    STUMPER

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BattingHand {
    LEFT,
    RIGHT
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BowlingType {

        RIGHT_ARM_FAST,
        RIGHT_ARM_FAST_MEDIUM,
        RIGHT_ARM_MEDIUM,
        RIGHT_ARM_OFF_SPIN,
        RIGHT_ARM_LEG_SPIN,

        LEFT_ARM_FAST,
        LEFT_ARM_MEDIUM,
        LEFT_ARM_ORTHODOX,
        LEFT_ARM_WRIST_SPIN

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.SubmitSquadRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchController {

    private final MatchService matchService;

    /**
     *  SINGLE ENTRY POINT  PHASE-0
     * Called ONLY when scorer clicks "Start Match"
     *
     * Flow:
     * UI navigation (Quick Match, Select Teams, Select Squads)  frontend only
     * Final "Proceed" button  THIS API
     */
    @PostMapping("/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Match> startMatch(
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody SubmitSquadRequest request
    ) {
        Match match = matchService.startMatch(scorerUserId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchRoleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchRoleController {

    private final MatchRoleService matchRoleService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}/assign-roles")
    public ResponseEntity<?> assignRoles(
            @PathVariable Long matchId,
            @Valid @RequestBody AssignSquadRolesRequest request
    ) {
        matchRoleService.assignRoles(matchId, request);
        return ResponseEntity.ok().build();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchSpecsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/specs")
@RequiredArgsConstructor
public class MatchSpecsController {

    private final MatchSpecsService matchSpecsService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applySpecs(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody MatchSpecsRequest request
    ) {
        Match match = matchSpecsService.applySpecs(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.service.TossService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/toss")
@RequiredArgsConstructor
public class TossController {

    private final TossService tossService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applyToss(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody TossRequest request
    ) {
        Match match = tossService.applyToss(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class AssignSquadRolesRequest {

    @NotNull
    private Long teamId;

    @NotEmpty
    private List<SquadRoleDTO> roles;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.BallType;
import in.crewplay.crewplay_backend.domain.match.MatchType;
import in.crewplay.crewplay_backend.domain.match.PitchType;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MatchSpecsRequest {

    @NotNull
    private MatchType matchType;

    @NotNull
    private BallType ballType;

    @NotNull
    private PitchType pitchType;

    @NotNull
    @Positive
    private Integer overs;

    private String city; // optional override
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadPlayerDTO {

    @NotNull
    private Long userId;

    private boolean captain;
    private boolean wicketKeeper;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadRoleDTO {

    @NotNull
    private Long userId;

    private boolean captain;

    private boolean wicketKeeper;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class SubmitSquadRequest {

    @NotNull
    private Long teamAId;

    @NotNull
    private Long teamBId;

    @NotEmpty
    private List<SquadPlayerDTO> teamA;

    @NotEmpty
    private List<SquadPlayerDTO> teamB;

    // Optional in Phase-0
    private String city;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.TossDecision;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TossRequest {

    @NotNull
    private Long tossWinnerTeamId;

    @NotNull
    private TossDecision decision;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java">
package in.crewplay.crewplay_backend.domain.match.innings.controller;

import in.crewplay.crewplay_backend.domain.match.innings.dto.InningsContextResponse;
import in.crewplay.crewplay_backend.domain.match.innings.dto.StartInningsRequest;
import in.crewplay.crewplay_backend.domain.match.innings.service.InningsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class InningsController {

    private final InningsService inningsService;

    @GetMapping("/{matchId}/innings/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<InningsContextResponse> getContext(
            @PathVariable Long matchId
    ) {
        return ResponseEntity.ok(
                inningsService.getInningsContext(matchId)
        );
    }

    @PostMapping("/{matchId}/innings/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> startInnings(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody StartInningsRequest request
    ) {
        inningsService.startInnings(matchId, scorerUserId, request);
        return ResponseEntity.ok("Innings started");
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsContextResponse {

    private InningsTeamDTO battingTeam;
    private InningsTeamDTO bowlingTeam;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsPlayerDTO {

    private Long userId;
    private String name;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class InningsTeamDTO {
    private Long teamId;
    private String teamName;
    private String logoUrl;
    private List<InningsPlayerDTO> players;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import in.crewplay.crewplay_backend.domain.match.BattingHand;
import in.crewplay.crewplay_backend.domain.match.BowlingType;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class StartInningsRequest {

    @NotNull
    private Long strikerUserId;

    @NotNull
    private Long nonStrikerUserId;

    @NotNull
    private BattingHand strikerHand;

    @NotNull
    private BattingHand nonStrikerHand;

    @NotNull
    private Long bowlerUserId;

    @NotNull
    private BowlingType bowlingType;


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java">
package in.crewplay.crewplay_backend.domain.match.innings;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_innings")
@Getter
@Setter
public class MatchInnings {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    private int inningsNumber; // 1 or 2

    //  Score state
    private int totalRuns = 0;
    private int totalWickets = 0;

    private int currentOver = 0;
    private int currentBall = 0; // 05 (valid balls only)

    private int maxOvers; // from match specs

    //  Batting state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "striker_id")
    private User striker;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "non_striker_id")
    private User nonStriker;

    //  Bowling state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "current_bowler_id")
    private User currentBowler;

    // Match state
    private boolean completed = false;

    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java">
package in.crewplay.crewplay_backend.domain.match.innings.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface MatchInningsRepository
        extends JpaRepository<MatchInnings, Long> {

    Optional<MatchInnings> findByMatch(Match match);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java">
package in.crewplay.crewplay_backend.domain.match.innings.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.innings.dto.*;
import in.crewplay.crewplay_backend.domain.match.innings.repository.MatchInningsRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class InningsService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadRepository;
    private final MatchInningsRepository matchInningsRepository;
    private final UserRepository userRepository;

    /**
     * STEP 1  Provide players for striker/bowler selection
     */
    public InningsContextResponse getInningsContext(Long matchId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Innings not available yet");
        }

        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found"));

        InningsContextResponse response = new InningsContextResponse();
        response.setBattingTeam(buildTeamDTO(battingTeam));
        response.setBowlingTeam(buildTeamDTO(bowlingTeam));

        return response;
    }

    private InningsTeamDTO buildTeamDTO(MatchTeam matchTeam) {

        InningsTeamDTO dto = new InningsTeamDTO();
        dto.setTeamId(matchTeam.getTeam().getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<InningsPlayerDTO> players = squadRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {
                    InningsPlayerDTO p = new InningsPlayerDTO();
                    p.setUserId(member.getUser().getId());
                    p.setName(member.getUser().getEmail()); // Replace later with real name
                    return p;
                })
                .toList();

        dto.setPlayers(players);
        return dto;
    }

    /**
     * STEP 2  Start innings
     */
    @Transactional
    public void startInnings(
            Long matchId,
            Long scorerUserId,
            StartInningsRequest request
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can start innings");
        }

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Match not ready for innings");
        }

        // 1. Validation for unique selections
        if (request.getStrikerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Striker and non-striker cannot be the same");
        }

        if (request.getBowlerUserId().equals(request.getStrikerUserId()) ||
                request.getBowlerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Bowler cannot be one of the opening batsmen");
        }

// 2. Fetch MatchTeams to validate squads
        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found for this match"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found for this match"));

// 3. Squad Validation using correct DTO getters
        boolean strikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getStrikerUserId());

        boolean nonStrikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getNonStrikerUserId());

        boolean bowlerValid = squadRepository
                .existsByMatchTeamAndUser_Id(bowlingTeam, request.getBowlerUserId());

        if (!strikerValid || !nonStrikerValid) {
            throw new IllegalStateException("Selected batsmen must belong to the batting team squad");
        }

        if (!bowlerValid) {
            throw new IllegalStateException("Selected bowler must belong to the bowling team squad");
        }

// 4. Initialize the Innings
        MatchInnings innings = new MatchInnings();
        innings.setMatch(match);
        innings.setInningsNumber(1);

// Map User entities via References (performance efficient)
        innings.setStriker(userRepository.getReferenceById(request.getStrikerUserId()));
        innings.setNonStriker(userRepository.getReferenceById(request.getNonStrikerUserId()));
        innings.setCurrentBowler(userRepository.getReferenceById(request.getBowlerUserId()));

// Map Hands and Types
        innings.setStrikerHand(request.getStrikerHand());
        innings.setNonStrikerHand(request.getNonStrikerHand());
        innings.setBowlerType(request.getBowlingType()); // Matches DTO field 'bowlingType'

        matchInningsRepository.save(innings);

        match.setStatus(MatchStatus.LIVE);
        matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java">
package in.crewplay.crewplay_backend.domain.match;

import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "match_squad_members",
        uniqueConstraints = @UniqueConstraint(columnNames = {"match_team_id", "user_id"})
)
@Getter
@Setter
public class MatchSquadMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "is_captain", nullable = false)
    private boolean captain = false;

    @Column(name = "is_wicket_keeper", nullable = false)
    private boolean wicketKeeper = false;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java">
    package in.crewplay.crewplay_backend.domain.match;

    import in.crewplay.crewplay_backend.domain.teams.Team;
    import jakarta.persistence.*;
    import lombok.Getter;
    import lombok.Setter;

    @Entity
    @Table(name = "match_teams",
    uniqueConstraints = @UniqueConstraint(columnNames = {"match_id", "side"}))
    @Getter
    @Setter
    public class MatchTeam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    // "A" or "B"
    @Column(nullable = false)
    private String side;
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchType {


    LIMITED_OVERS,
    BOX_CRICKET,
    TEST
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum PitchType {
    GREEN,
    DUSTY,
    HARD,
    MAT
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MatchRepository extends JpaRepository<Match, Long> {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java">
package in.crewplay.crewplay_backend.domain.match.scoring.entity;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.ExtraType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.Id;

import java.time.LocalDateTime;

@Entity
@Table(name = "ball_events")
@Getter
@Setter
public class BallEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "innings_id", nullable = false)
    private MatchInnings innings;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowler_id", nullable = false)
    private User bowler;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "batsman_id", nullable = false)
    private User batsman;

    // Over tracking
    private int overNumber;
    private int ballNumber; // only for valid deliveries

    // Core ball classification
    @Enumerated(EnumType.STRING)
    private BallResultType ballResultType;

    // Runs
    private int runsOffBat = 0;
    private int extraRuns = 0;

    // Extras classification
    @Enumerated(EnumType.STRING)
    private ExtraType extraType;

    // Wicket
    private boolean isWicket = false;

    @Enumerated(EnumType.STRING)
    private WicketType wicketType;

    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum BallResultType {

    NORMAL,      // Valid delivery
    WIDE,
    NO_BALL,
    DEAD_BALL
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum ExtraType {
    WIDE,
    NO_BALL,
    BYE,
    LEG_BYE,
    PENALTY
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum WicketType {
    BOWLED,
    CAUGHT,
    LBW,
    RUN_OUT,
    STUMPED,
    HIT_WICKET,
    OBSTRUCTING_FIELD,
    RETIRED_OUT,
    TIMED_OUT,
    HANDLED_BALL,
    HIT_THE_BALL_TWICE
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.dto.SquadRoleDTO;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MatchRoleService {

    private final MatchSquadMemberRepository squadMemberRepository;

    @Transactional
    public void assignRoles(Long matchId, AssignSquadRolesRequest request) {

        List<MatchSquadMember> squadMembers =
                squadMemberRepository.findByMatchTeam_Match_IdAndMatchTeam_Team_Id(
                        matchId,
                        request.getTeamId()
                );

        if (squadMembers.isEmpty()) {
            throw new IllegalStateException("No squad found for this team in the match");
        }

        Map<Long, MatchSquadMember> squadMap =
                squadMembers.stream()
                        .collect(Collectors.toMap(
                                m -> m.getUser().getId(),
                                Function.identity()
                        ));

        long captainCount =
                request.getRoles().stream()
                        .filter(SquadRoleDTO::isCaptain)
                        .count();

        if (captainCount != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }

        // Reset roles first (idempotent)
        squadMembers.forEach(m -> {
            m.setCaptain(false);
            m.setWicketKeeper(false);
        });

        // Apply new roles
        for (SquadRoleDTO dto : request.getRoles()) {

            MatchSquadMember member = squadMap.get(dto.getUserId());

            if (member == null) {
                throw new IllegalStateException(
                        "User " + dto.getUserId() + " is not part of this squad"
                );
            }

            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
        }

        squadMemberRepository.saveAll(squadMembers);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import in.crewplay.crewplay_backend.domain.match.dto.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.Repository.TeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.lang.System.in;

@Service
@RequiredArgsConstructor
public class MatchService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final TeamRepository teamRepository;
    private final UserRepository userRepository;

    /**
     *  SINGLE ENTRY POINT  PHASE-0
     * Called when scorer clicks "Start Match"
     */
    @Transactional
    public Match startMatch(Long scorerId, SubmitSquadRequest request) {

        // 1 VALIDATION (Phase-0 invariants)
        validateSquads(
                request.getTeamA().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamB().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamA().stream().filter(SquadPlayerDTO::isCaptain).count(),
                request.getTeamB().stream().filter(SquadPlayerDTO::isCaptain).count()
        );

        // 2 CREATE MATCH
        Match match = new Match();
        match.setScorerUserId(scorerId);
        match.setCity(request.getCity()); // optional in Phase-0
        match.setStatus(MatchStatus.READY); // NOT LIVE
        match = matchRepository.save(match);

        // 3 TEAM A + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamAId(),
                request.getTeamA(),
                "A"
        );

        // 4 TEAM B + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamBId(),
                request.getTeamB(),
                "B"
        );

        return match;
    }

    /**
     *  Phase-0 squad rules
     */
    private void validateSquads(
            List<Long> teamAPlayers,
            List<Long> teamBPlayers,
            long teamACaptains,
            long teamBCaptains
    ) {
        if (teamAPlayers.size() < 3 || teamBPlayers.size() < 3) {
            throw new IllegalStateException("Each team must have at least 3 players");
        }

        Set<Long> intersection = new HashSet<>(teamAPlayers);
        intersection.retainAll(teamBPlayers);

        if (!intersection.isEmpty()) {
            throw new IllegalStateException("Same player cannot play for both teams");
        }

        if (teamACaptains != 1 || teamBCaptains != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }
    }

    /**
     *  Helper  persists MatchTeam + MatchSquadMembers
     */
    private void saveTeamAndSquad(
            Match match,
            Long teamId,
            List<SquadPlayerDTO> players,
            String side
    ) {
        // Create MatchTeam
        MatchTeam matchTeam = new MatchTeam();
        matchTeam.setMatch(match);
        matchTeam.setTeam(teamRepository.getReferenceById(teamId));
        matchTeam.setSide(side);
        matchTeam = matchTeamRepository.save(matchTeam);

        // Save squad members
        for (SquadPlayerDTO dto : players) {
            MatchSquadMember member = new MatchSquadMember();
            member.setMatchTeam(matchTeam);
            member.setUser(userRepository.getReferenceById(dto.getUserId()));
            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
            squadMemberRepository.save(member);
        }
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MatchSpecsService {

    private final MatchRepository matchRepository;

    @Transactional
    public Match applySpecs(Long scorerUserId, Long matchId, MatchSpecsRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        //  Ensure only creator scorer can modify
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("You are not allowed to modify this match");
        }

        //  Allow specs only if match is in READY or DRAFT
        if (match.getStatus() != MatchStatus.READY &&
                match.getStatus() != MatchStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify specs after match started");
        }

        //  Apply specs
        match.setMatchType(request.getMatchType());
        match.setBallType(request.getBallType());
        match.setPitchType(request.getPitchType());
        match.setOvers(request.getOvers());

        if (request.getCity() != null && !request.getCity().isBlank()) {
            match.setCity(request.getCity());
        }

        //  Move status forward
        match.setStatus(MatchStatus.SPECS_LOCKED);

        return matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TossService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;

    @Transactional
    public Match applyToss(Long scorerUserId, Long matchId, TossRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        //  Ownership check
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Not allowed");
        }

        //  Must be VERIFIED now (NOT SPECS_LOCKED)
        if (match.getStatus() != MatchStatus.VERIFIED) {
            throw new IllegalStateException("Toss allowed only after verification");
        }

        //  Fetch match teams
        List<MatchTeam> teams = matchTeamRepository.findByMatch_Id(matchId);
        if (teams.size() != 2) {
            throw new IllegalStateException("Match teams not properly initialized");
        }

        MatchTeam teamA = teams.get(0);
        MatchTeam teamB = teams.get(1);

        boolean validTeam =
                teamA.getTeam().getId().equals(request.getTossWinnerTeamId()) ||
                        teamB.getTeam().getId().equals(request.getTossWinnerTeamId());

        if (!validTeam) {
            throw new IllegalStateException("Invalid toss winner");
        }

        //  Apply toss
        match.setTossWinnerTeamId(request.getTossWinnerTeamId());
        match.setTossDecision(request.getDecision());

        Long battingTeamId;
        Long bowlingTeamId;

        if (request.getDecision() == TossDecision.BAT) {
            battingTeamId = request.getTossWinnerTeamId();
        } else {
            battingTeamId =
                    teamA.getTeam().getId().equals(request.getTossWinnerTeamId())
                            ? teamB.getTeam().getId()
                            : teamA.getTeam().getId();
        }

        bowlingTeamId =
                teamA.getTeam().getId().equals(battingTeamId)
                        ? teamB.getTeam().getId()
                        : teamA.getTeam().getId();

        match.setBattingTeamId(battingTeamId);
        match.setBowlingTeamId(bowlingTeamId);

        //  IMPORTANT: Move to TOSS_DONE (NOT LIVE)
        match.setStatus(MatchStatus.TOSS_DONE);

        return matchRepository.save(match);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java">
package in.crewplay.crewplay_backend.domain.match;

public enum TossDecision {

    BAT,
    BOWL

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java">
package in.crewplay.crewplay_backend.domain.match.verification.controller;

import in.crewplay.crewplay_backend.domain.match.verification.dto.VerificationContextResponse;
import in.crewplay.crewplay_backend.domain.match.verification.service.MatchVerificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchVerificationController {

    private final MatchVerificationService verificationService;

    @GetMapping("/{matchId}/verification/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<VerificationContextResponse> getContext(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId
    ) {

        return ResponseEntity.ok(
                verificationService.getVerificationContext(matchId, scorerUserId)
        );
    }

    @PostMapping("/{matchId}/verification/send")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> sendVerification(
            @PathVariable Long matchId,
            @RequestParam Long matchTeamId,
            @RequestParam Long selectedUserId,
            @RequestAttribute("userId") Long scorerUserId
    ) {
        verificationService.sendVerificationRequest(
                scorerUserId,
                matchId,
                matchTeamId,
                selectedUserId
        );
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/accept")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> accept(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.acceptVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/reject")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> reject(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.rejectVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationContextResponse {

    private VerificationTeamDTO teamA;
    private VerificationTeamDTO teamB;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationPlayerDTO {

    private Long userId;
    private String name;
    private boolean isGuest;
    private boolean isScorer;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class VerificationTeamDTO {

    private Long matchTeamId;
    private String teamName;
    private String logoUrl;
    private List<VerificationPlayerDTO> players;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java">
package in.crewplay.crewplay_backend.domain.match.verification;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_verifications")
@Getter
@Setter
public class MatchVerification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Which match
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    // Team side (A / B)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    // Selected verifier (must be registered user)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "verifier_user_id", nullable = false)
    private User verifier;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MatchVerificationStatus status = MatchVerificationStatus.PENDING;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "responded_at")
    private LocalDateTime respondedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java">
package in.crewplay.crewplay_backend.domain.match.verification;

public enum MatchVerificationStatus {
    PENDING,
    VERIFIED,
    REJECTED
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java">
package in.crewplay.crewplay_backend.domain.match.verification.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchVerificationRepository extends JpaRepository<MatchVerification, Long> {

    Optional<MatchVerification> findByMatchAndMatchTeam(Match match, MatchTeam matchTeam);

    List<MatchVerification> findByMatch(Match match);

    boolean existsByMatchAndStatus(Match match, MatchVerificationStatus status);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java">
package in.crewplay.crewplay_backend.domain.match.verification.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import in.crewplay.crewplay_backend.domain.match.verification.dto.*;
import in.crewplay.crewplay_backend.domain.match.verification.repository.MatchVerificationRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class MatchVerificationService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final MatchVerificationRepository matchVerificationRepository;
    private final UserRepository userRepository;

    public VerificationContextResponse getVerificationContext(Long matchId, Long scorerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not ready for verification");
        }

        List<MatchTeam> matchTeams = matchTeamRepository.findByMatch(match);

        MatchTeam teamA = matchTeams.stream()
                .filter(mt -> "A".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team A not found"));

        MatchTeam teamB = matchTeams.stream()
                .filter(mt -> "B".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team B not found"));

        VerificationContextResponse response = new VerificationContextResponse();
        response.setTeamA(buildTeamDTO(teamA, scorerUserId));
        response.setTeamB(buildTeamDTO(teamB, scorerUserId));

        return response;
    }

    private VerificationTeamDTO buildTeamDTO(MatchTeam matchTeam, Long scorerUserId) {

        VerificationTeamDTO dto = new VerificationTeamDTO();
        dto.setMatchTeamId(matchTeam.getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<VerificationPlayerDTO> players = squadMemberRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {

                    VerificationPlayerDTO playerDTO = new VerificationPlayerDTO();
                    playerDTO.setUserId(member.getUser().getId());
                    playerDTO.setName(member.getUser().getEmail()); // or better name if available
                    playerDTO.setGuest(false); // squad only contains registered users
                    playerDTO.setScorer(member.getUser().getId().equals(scorerUserId));

                    return playerDTO;
                })
                .toList();

        dto.setPlayers(players);

        return dto;
    }

    @Transactional
    public void sendVerificationRequest(
            Long scorerUserId,
            Long matchId,
            Long matchTeamId,
            Long selectedUserId
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not in verification stage");
        }

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can send verification");
        }

        if (scorerUserId.equals(selectedUserId)) {
            throw new IllegalStateException("Scorer cannot verify his own match");
        }

        MatchTeam matchTeam = matchTeamRepository.findById(matchTeamId)
                .orElseThrow(() -> new RuntimeException("Match team not found"));

        // Ensure player is in squad
        boolean inSquad = squadMemberRepository.findByMatchTeam(matchTeam)
                .stream()
                .anyMatch(member -> member.getUser().getId().equals(selectedUserId));

        if (!inSquad) {
            throw new IllegalStateException("Selected player not in squad");
        }

        // Prevent duplicate request per team
        if (matchVerificationRepository.findByMatchAndMatchTeam(match, matchTeam).isPresent()) {
            throw new IllegalStateException("Verification already sent for this team");
        }

        MatchVerification verification = new MatchVerification();
        verification.setMatch(match);
        verification.setMatchTeam(matchTeam);
        verification.setVerifier(
                userRepository.getReferenceById(selectedUserId)
        );
        verification.setStatus(MatchVerificationStatus.PENDING);

        matchVerificationRepository.save(verification);
    }

    @Transactional
    public void acceptVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.VERIFIED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        checkAndPromoteMatch(match);
    }

    @Transactional
    public void rejectVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.REJECTED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        match.setStatus(MatchStatus.DRAFT); // rollback stage
        matchRepository.save(match);
    }

    private void checkAndPromoteMatch(Match match) {

        boolean hasPending = matchVerificationRepository
                .existsByMatchAndStatus(match, MatchVerificationStatus.PENDING);

        if (!hasPending) {
            match.setStatus(MatchStatus.VERIFIED);
            matchRepository.save(match);
        }
    }



}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/enums/TeamStatus.java">
    package in.crewplay.crewplay_backend.domain.teams.enums;

    public enum TeamStatus {

    TEMPORARY, // Created inside match flow
    ACTIVE, // Permanent team
    ARCHIVED
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java">
package in.crewplay.crewplay_backend.domain.user;

public enum ExperienceLevel {
    BEGINNER,
    INTERMEDIATE,
    ADVANCED,
    PROFESSIONAL

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Gender {
    MALE,
    FEMALE,
    OTHER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java">
package in.crewplay.crewplay_backend.domain.user;

public enum PlayingRole {
    WICKET_KEEPER,
    OPENING_BATSMAN,
    MIDDLE_ORDER_BATSMAN,
    LOWER_ORDER_BATSMAN,
    ALL_ROUNDER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Role {
    PLAYER,
    SCORER,
    TEAM_MANAGER
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/User.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "mobile_number", nullable = false, unique = true)
    private String mobileNumber;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "is_active")
    private Boolean isActive = true;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_follows",
        uniqueConstraints = @UniqueConstraint(
                columnNames = {"follower_user_id", "following_user_id"}
        )
)
@Getter
@Setter
public class UserFollow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "follower_user_id", nullable = false)
    private User follower;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "following_user_id", nullable = false)
    private User following;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java">
package in.crewplay.crewplay_backend.match_setup.Controller;

public class MatchSetupController {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class CreateQuickMatchRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectSquadRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectTeamRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java">
package in.crewplay.crewplay_backend.match_setup.dto.response;

public class MatchSetupResponse {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchRepository {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchSquadRepository {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java">
package in.crewplay.crewplay_backend.match_setup.Service;

public class MatchSetupService {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java">
package in.crewplay.crewplay_backend.Scorer.Controller;

import in.crewplay.crewplay_backend.Scorer.Service.ScorerService;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/scorer")
@RequiredArgsConstructor
public class ScorerController {

    private final ScorerService scorerService;

    @GetMapping("/me")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<ScorerProfile> getMyScorerProfile(
            @RequestAttribute("userId") Long userId
    ) {
        ScorerProfile profile = scorerService.getOrCreateScorerProfile(userId);
        return ResponseEntity.ok(profile);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java">
package in.crewplay.crewplay_backend.Scorer.Repository;

import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ScorerProfileRepository extends JpaRepository<ScorerProfile, Long> {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java">
package in.crewplay.crewplay_backend.Scorer.Service;

import in.crewplay.crewplay_backend.Scorer.Repository.ScorerProfileRepository;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class ScorerService {

    private final ScorerProfileRepository scorerProfileRepository;
    private final UserRepository userRepository;

    public ScorerProfile getOrCreateScorerProfile(Long userId) {

        return scorerProfileRepository.findById(userId)
                .orElseGet(() -> {
                    User user = userRepository.findById(userId)
                            .orElseThrow(() -> new RuntimeException("User not found"));

                    ScorerProfile scorerProfile = new ScorerProfile();
                    scorerProfile.setId(userId);
                    scorerProfile.setUser(user);

                    // Auto-copy from User
                    scorerProfile.setEmail(user.getEmail());
                    scorerProfile.setMobileNumber(user.getMobileNumber());
                    scorerProfile.setName(extractNameFromEmail(user.getEmail()));

                    scorerProfile.setMemberSince(LocalDateTime.now());
                    scorerProfile.setCreatedAt(LocalDateTime.now());

                    return scorerProfileRepository.save(scorerProfile);
                });
    }

    private String extractNameFromEmail(String email) {
        return email.split("@")[0];
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Controller/TeamRosterController.java">
package in.crewplay.crewplay_backend.team_roster.Controller;

public class TeamRosterController {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddGuestPlayerRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddPlayerByMobileRequest {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java">
package in.crewplay.crewplay_backend.team_roster.dto.response;

public class TeamMemberResponse {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Service/TeamRosterService.java">
package in.crewplay.crewplay_backend.team_roster.Service;

public class TeamRosterService {
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java">
package in.crewplay.crewplay_backend.team.dto.response;

public class TeamResponse {
}
</file>

<file path="src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java">
package in.crewplay.crewplay_backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CrewplayBackendApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java">
package in.crewplay.crewplay_backend.Auth.filter;


import in.crewplay.crewplay_backend.Auth.util.JwtTokenParser;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenParser tokenParser;

    public JwtAuthenticationFilter(JwtTokenParser tokenParser) {
        this.tokenParser = tokenParser;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return request.getRequestURI().startsWith("/auth/");
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(7);

        if (!tokenParser.validateToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        Long userId = tokenParser.extractUserId(token);
        List<String> roles = tokenParser.extractRoles(token);
        String activeRole = tokenParser.extractActiveRole(token);

        List<SimpleGrantedAuthority> authorities =
                roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userId,
                        null,
                        authorities
                );

        authentication.setDetails(
                new WebAuthenticationDetailsSource().buildDetails(request)
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);

        //  CRITICAL FOR CONTROLLERS
        request.setAttribute("userId", userId);
        request.setAttribute("active_role", activeRole);

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java">
package in.crewplay.crewplay_backend.common.enums;

public enum PlayerAddMethod {
    MOBILE_NUMBER,
    TEAM_CODE,
    MANUAL_GUEST
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java">
package in.crewplay.crewplay_backend.config;


import in.crewplay.crewplay_backend.Auth.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity //  REQUIRED for @PreAuthorize
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http
                .csrf(csrf -> csrf.disable())
                .formLogin(form -> form.disable())
                .httpBasic(basic -> basic.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .anyRequest().authenticated()
                );

        http.addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
        );

        return http.build();
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchStatus {


    DRAFT,                   // Squads not finalized
    READY,                   // Squads finalized
    SPECS_LOCKED,            // Match specs saved
    AWAITING_VERIFICATION,   // Waiting for team confirmations
    VERIFIED,                // Both teams confirmed
    TOSS_DONE,               // Toss completed
    LIVE,                    // Innings started
    COMPLETED                // Match finished

}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchSquadMemberRepository extends JpaRepository<MatchSquadMember, Long> {
    List<MatchSquadMember> findByMatchTeam(MatchTeam matchTeam);

    List<MatchSquadMember>
    findByMatchTeam_Match_IdAndMatchTeam_Team_Id(Long matchId, Long teamId);
    boolean existsByMatchTeam_Match_IdAndMatchTeam_Team_IdAndUser_Id(
            Long matchId,
            Long teamId,
            Long userId
    );


    boolean existsByMatchTeamAndUser_Id(MatchTeam matchTeam, Long userId);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchTeamRepository extends JpaRepository<MatchTeam, Long> {
    List<MatchTeam> findByMatch(Match match);
    List<MatchTeam> findByMatch_Id(Long matchId);

    Optional<MatchTeam> findByMatch_IdAndTeam_Id(Long matchId, Long teamId);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/TeamMember.java">
package in.crewplay.crewplay_backend.domain.team;

import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "team_members",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"team_id", "user_id"})
        }
)
@Getter
@Setter
public class TeamMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- RELATIONS ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    /**
     * Can be NULL for guest players
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    // ---------- PLAYER INFO ----------

    @Column(name = "display_name", nullable = false)
    private String displayName;

    @Column(name = "mobile_number", nullable = false)
    private String mobileNumber;

    @Column(name = "is_guest", nullable = false)
    private Boolean isGuest = false;

    // ---------- HOW THEY WERE ADDED ----------

    @Enumerated(EnumType.STRING)
    @Column(name = "add_method", nullable = false)
    private PlayerAddMethod addMethod;

    @Column(name = "added_by_scorer_id", nullable = false)
    private Long addedByScorerId;

    // ---------- TRUST / REPORTING (PHASE-1 READY) ----------

    @Column(name = "reported", nullable = false)
    private Boolean reported = false;

    // ---------- SYSTEM ----------

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_profiles")
@Getter
@Setter
public class PlayerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Enumerated(EnumType.STRING)
    private Gender gender;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // CRICKET INFO
    @Enumerated(EnumType.STRING)
    @Column(name = "playing_role")
    private PlayingRole playingRole;

    private String battingStyle;
    private String bowlingStyle;

    @Enumerated(EnumType.STRING)
    @Column(name = "experience_level")
    private ExperienceLevel experienceLevel;

    // LOCATION
    private String city;

    // MEDIA
    @Column(name = "profile_image_url")
    private String profileImageUrl;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SYSTEM
    @Column(name = "is_profile_complete")
    private Boolean isProfileComplete = false;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository; // Ensure this matches your folder

import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    // This allows .findByEmail() to work in AuthController
    Optional<User> findByEmail(String email);
    Optional<User> findByMobileNumber(String mobileNumber);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository;

import in.crewplay.crewplay_backend.domain.user.UserRole;
import in.crewplay.crewplay_backend.domain.user.Role;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserRoleRepository extends JpaRepository<UserRole, Long> {

    List<UserRole> findByUserId(Long userId);

    Optional<UserRole> findByUserIdAndRole(Long userId, Role role);

    Optional<UserRole> findByUserIdAndIsActiveTrue(Long userId);


}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "team_manager_profiles")
@Getter
@Setter
public class TeamManagerProfile {

    @Id
    private Long id; // SAME AS users.id

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // TEAM MANAGEMENT META
    @Column(name = "teams_handled_count")
    private Long teamsHandledCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_roles",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "role"})
)
@Getter
@Setter
public class UserRole {

    @Id // Corrected Import: jakarta.persistence.Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private Boolean isActive = false; // Added this for your logic to work!

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team_roster/Repository/TeamMemberRepository.java">
package in.crewplay.crewplay_backend.team_roster.repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.TeamMember;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamMemberRepository extends JpaRepository<TeamMember, Long> {

    Optional<TeamMember> findByTeamAndUser(Team team, User user);

    List<TeamMember> findByTeam(Team team);

    List<TeamMember> findByTeam_Id(Long teamId);

    boolean existsByTeam_IdAndUser_Id(Long teamId, Long userId);


    boolean existsByTeamAndUser(Team team, User user);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java">
package in.crewplay.crewplay_backend.team.Controller;


import in.crewplay.crewplay_backend.team.Service.TeamService;
import in.crewplay.crewplay_backend.team.dto.request.CreateTeamRequest;
import in.crewplay.crewplay_backend.team.dto.request.VerifyCaptainRequest;
import in.crewplay.crewplay_backend.domain.teams.Team;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/teams")
@RequiredArgsConstructor
public class TeamController {

    private final TeamService teamService;

    /**
     * STEP 1  Send captain verification OTP (EMAIL)
     */
    @PostMapping("/verify-captain")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<String> verifyCaptain(
            @RequestBody VerifyCaptainRequest request
    ) {
        teamService.sendCaptainVerificationOtp(request.getCaptainEmail());
        return ResponseEntity.ok("OTP sent to captain email");
    }

    /**
     * STEP 2  Create team (OTP already verified on frontend)
     */
    @PostMapping("/create")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Team> createTeam(
            @RequestAttribute("userId") Long scorerUserId,
            @RequestBody CreateTeamRequest request
    ) {
        Team team = teamService.createTeam(
                scorerUserId,
                request.getTeamName(),
                request.getCity(),
                request.getLogoUrl(),
                request.getCaptainMobileNumber()
        );
        return ResponseEntity.ok(team);
    }
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CreateTeamRequest {

    private String teamName;
    private String city;
    private String logoUrl;
    private String captainMobileNumber;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyCaptainRequest {
    private String captainEmail;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java">
package in.crewplay.crewplay_backend.team.util;

import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class TeamCodeGenerator {

    public String generate() {
        return UUID.randomUUID()
                .toString()
                .substring(0, 8)
                .toUpperCase();
    }
}
</file>

<file path="src/main/resources/application.yaml">
server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/crewplay
    username: crewplay
    password: crewplay
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    open-in-view: false

  redis:
    host: localhost
    port: 6379

  mail:
    host: smtp.gmail.com
    port: 587
    username: your_email@gmail.com
    password: your_app_password
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

jwt:
  # This secret MUST be at least 32 characters for HS256
  secret: crewplay-super-secret-key-must-be-long-enough-32chars
  expiration: 86400000 # 1 day
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java">
package in.crewplay.crewplay_backend.domain.match;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDateTime;

@Entity
@Table(name = "matches")
@Getter
@Setter
public class Match {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "scorer_user_id", nullable = false)
    private Long scorerUserId;

    @Enumerated(EnumType.STRING)
    private MatchStatus status = MatchStatus.DRAFT;

    private String city;

    //  MATCH SPECS
    @Enumerated(EnumType.STRING)
    @Column(name = "match_type")
    private MatchType matchType;

    @Enumerated(EnumType.STRING)
    @Column(name = "ball_type")
    private BallType ballType;

    @Enumerated(EnumType.STRING)
    @Column(name = "pitch_type")
    private PitchType pitchType;

    private Integer overs;

    //  TOSS INFO
    @Column(name = "toss_winner_team_id")
    private Long tossWinnerTeamId;

    @Enumerated(EnumType.STRING)
    @Column(name = "toss_decision")
    private TossDecision tossDecision; // Only one declaration now

    //  LIVE GAME STATE
    @Column(name = "batting_team_id")
    private Long battingTeamId;

    @Column(name = "bowling_team_id")
    private Long bowlingTeamId;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/team/Team.java">
    package in.crewplay.crewplay_backend.domain.team;

    import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
    import in.crewplay.crewplay_backend.domain.user.User;
    import jakarta.persistence.*;
    import lombok.Getter;
    import lombok.Setter;

    import java.time.LocalDateTime;

    @Entity
    @Table(
    name = "teams",
    uniqueConstraints = {
    @UniqueConstraint(columnNames = "team_code"),
    @UniqueConstraint(columnNames = {"name", "city"})
    }
    )
    @Getter
    @Setter
    public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- BASIC INFO ----------

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String city;

    @Column(name = "logo_url")
    private String logoUrl;

    // ---------- TEAM CODE (JOINING / QR / LINK) ----------

    @Column(name = "team_code", nullable = false, unique = true)
    private String teamCode;

    // ---------- CAPTAIN & OWNERSHIP ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "captain_user_id", nullable = false)
    private User captain;


    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TeamStatus status = TeamStatus.TEMPORARY;

    // ---------- TRUST / VERIFICATION ----------

    @Column(name = "is_verified", nullable = false)
    private Boolean isVerified = false; // Phase-0 always false

    @Column(name = "verification_method")
    private String verificationMethod; // EMAIL (Phase-0)

    @Column(name = "verified_at")
    private LocalDateTime verifiedAt;

    // ---------- SYSTEM ----------

    @Column(name = "created_by_scorer_id", nullable = false)
    private Long createdByScorerId;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    }
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "scorer_profiles")
@Getter
@Setter
public class ScorerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SCORER TRUST SIGNAL
    @Column(name = "unverified_matches_count")
    private Long unverifiedMatchesCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    private Integer matchesScored = 0;
    private Double accuracy = 100.0;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Repository/TeamRepository.java">
package in.crewplay.crewplay_backend.team.Repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamRepository extends JpaRepository<Team, Long> {

    Optional<Team> findByTeamCode(String teamCode);

    List<Team> findByCreatedByScorerId(Long scorerId);

    boolean existsByNameAndCity(String name, String city);

    List<Team> findByCaptainAndStatus(User captain, TeamStatus status);
}
</file>

<file path="src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java">
    package in.crewplay.crewplay_backend.team.Service;

    import in.crewplay.crewplay_backend.Auth.service.OtpService;
    import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
    import in.crewplay.crewplay_backend.domain.teams.Team;
    import in.crewplay.crewplay_backend.domain.teams.TeamMember;
    import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
    import in.crewplay.crewplay_backend.domain.user.User;
    import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
    import in.crewplay.crewplay_backend.team.Repository.TeamRepository;
    import in.crewplay.crewplay_backend.team.util.TeamCodeGenerator;
    import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
    import lombok.RequiredArgsConstructor;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.time.LocalDateTime;

    @Service
    @RequiredArgsConstructor
    public class TeamService {

    private final TeamRepository teamRepository;
    private final UserRepository userRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final OtpService otpService;
    private final TeamCodeGenerator teamCodeGenerator;

    /**
    * STEP 1  Send captain verification OTP (EMAIL)
    */
    public void sendCaptainVerificationOtp(String captainEmail) {
    otpService.generateAndStoreOtp(captainEmail);
    }

    /**
    * STEP 2  Create Team (OTP already verified)
    *
    * IMPORTANT:
    * - Team is created as TEMPORARY
    * - TEAM_MANAGER role is NOT assigned here
    * - Ownership will be granted after match completion
    */
    @Transactional
    public Team createTeam(
    Long scorerUserId,
    String teamName,
    String city,
    String logoUrl,
    String captainMobileNumber
    ) {

    // 1 Prevent duplicate team in same city
    if (teamRepository.existsByNameAndCity(teamName, city)) {
    throw new RuntimeException("Team already exists in this city");
    }

    // 2 Captain must be an existing user
    User captain = userRepository.findByMobileNumber(captainMobileNumber)
    .orElseThrow(() -> new RuntimeException("Captain must be an existing user"));

    // 3 Generate team code
    String teamCode = teamCodeGenerator.generate();

    // 4 Create TEMPORARY team
    Team team = new Team();
    team.setName(teamName);
    team.setCity(city);
    team.setLogoUrl(logoUrl);
    team.setTeamCode(teamCode);
    team.setCaptain(captain);
    team.setCreatedByScorerId(scorerUserId);
    team.setVerificationMethod("EMAIL");
    team.setStatus(TeamStatus.TEMPORARY); //  CRITICAL CHANGE
    team.setCreatedAt(LocalDateTime.now());

    Team savedTeam = teamRepository.save(team);

    // 5 Add captain to roster
    TeamMember captainMember = new TeamMember();
    captainMember.setTeam(savedTeam);
    captainMember.setUser(captain);
    captainMember.setDisplayName(extractDisplayName(captain));
    captainMember.setMobileNumber(captainMobileNumber);
    captainMember.setAddMethod(PlayerAddMethod.TEAM_CODE);
    captainMember.setIsGuest(false);
    captainMember.setReported(false);
    captainMember.setAddedByScorerId(scorerUserId);
    captainMember.setCreatedAt(LocalDateTime.now());

    teamMemberRepository.save(captainMember);

    //  REMOVED:
    // assignTeamManagerRoleIfMissing(captain);

    return savedTeam;
    }

    /**
    * Fallback display name logic (Phase-0 safe)
    */
    private String extractDisplayName(User user) {
    if (user.getEmail() != null) {
    return user.getEmail().split("@")[0];
    }
    return user.getMobileNumber();
    }
    }
</file>

</files>
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/Controller/AuthController.java">
package in.crewplay.crewplay_backend.Auth.Controller;


import in.crewplay.crewplay_backend.Auth.DTO.Request.RequestOtpRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.StartJourneyRequest;
import in.crewplay.crewplay_backend.Auth.DTO.Request.VerifyOtpRequest;
import in.crewplay.crewplay_backend.Auth.service.EmailService;
import in.crewplay.crewplay_backend.Auth.util.JwtUtil;
import in.crewplay.crewplay_backend.Auth.service.OtpService;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRoleRepository;
import in.crewplay.crewplay_backend.domain.user.Role;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.UserRole;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/auth")
public class AuthController {

    private final OtpService otpService;
    private final EmailService emailService;
    private final UserRepository userRepository;
    private final UserRoleRepository userRoleRepository;
    private final JwtUtil jwtUtil;

    public AuthController(
            OtpService otpService,
            EmailService emailService,
            UserRepository userRepository,
            UserRoleRepository userRoleRepository,
            JwtUtil jwtUtil
    ) {
        this.otpService = otpService;
        this.emailService = emailService;
        this.userRepository = userRepository;
        this.userRoleRepository = userRoleRepository;
        this.jwtUtil = jwtUtil;
    }

    /**
     * STEP 1  REQUEST OTP (Signup + Login)
     */
    @PostMapping("/request-otp")
    public void requestOtp(@Valid @RequestBody RequestOtpRequest request) {
        String otp = otpService.generateAndStoreOtp(request.getEmail());
        emailService.sendOtpEmail(request.getEmail(), otp);
    }

    /**
     * STEP 2  VERIFY OTP (Identity Proven)
     */
    @PostMapping("/verify-otp")
    public Long verifyOtp(@Valid @RequestBody VerifyOtpRequest request) {

        boolean valid = otpService.verifyOtp(request.getEmail(), request.getOtp());
        if (!valid) {
            throw new RuntimeException("Invalid or expired OTP");
        }

        User user = userRepository.findByEmail(request.getEmail())
                .orElseGet(() -> {
                    User newUser = new User();
                    newUser.setEmail(request.getEmail());
                    return userRepository.save(newUser);
                });

        // Frontend only needs userId at this stage
        return user.getId();
    }

    /**
     * STEP 3  START JOURNEY (ONE ACTIVE ROLE GUARANTEED)
     */
    @PostMapping("/start-journey/{userId}")
    public String startJourney(
            @PathVariable Long userId,
            @Valid @RequestBody StartJourneyRequest request
    ) {
        Role selectedRole = request.getRole();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // 1 Deactivate ALL existing roles
        List<UserRole> existingRoles = userRoleRepository.findByUserId(userId);
        existingRoles.forEach(ur -> ur.setIsActive(false));
        userRoleRepository.saveAll(existingRoles);

        // 2 Activate or create the selected role
        UserRole currentRole = userRoleRepository
                .findByUserIdAndRole(userId, selectedRole)
                .orElseGet(() -> {
                    UserRole ur = new UserRole();
                    ur.setUser(user);
                    ur.setRole(selectedRole);
                    return ur;
                });

        currentRole.setIsActive(true);
        userRoleRepository.save(currentRole);

        // 3 Collect ALL roles owned by user (for JWT)
        List<String> roleNames = userRoleRepository.findByUserId(userId)
                .stream()
                .map(ur -> ur.getRole().name())
                .toList();

        // 4 Issue JWT with ACTIVE ROLE
        return jwtUtil.generateToken(
                userId,
                roleNames,
                selectedRole.name()
        );
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/RequestOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class RequestOtpRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/StartJourneyRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import in.crewplay.crewplay_backend.domain.user.Role;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class StartJourneyRequest {

    @NotNull(message = "Role must be selected")
    private Role role;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/DTO/Request/VerifyOtpRequest.java">
package in.crewplay.crewplay_backend.Auth.DTO.Request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyOtpRequest {

    @NotBlank
    @Email
    private String email;

    @NotBlank(message = "OTP is required")
    private String otp;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/filter/JwtAuthenticationFilter.java">
package in.crewplay.crewplay_backend.Auth.filter;


import in.crewplay.crewplay_backend.Auth.util.JwtTokenParser;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenParser tokenParser;

    public JwtAuthenticationFilter(JwtTokenParser tokenParser) {
        this.tokenParser = tokenParser;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return request.getRequestURI().startsWith("/auth/");
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String authHeader = request.getHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String token = authHeader.substring(7);

        if (!tokenParser.validateToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        Long userId = tokenParser.extractUserId(token);
        List<String> roles = tokenParser.extractRoles(token);
        String activeRole = tokenParser.extractActiveRole(token);

        List<SimpleGrantedAuthority> authorities =
                roles.stream()
                        .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                        .collect(Collectors.toList());

        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userId,
                        null,
                        authorities
                );

        authentication.setDetails(
                new WebAuthenticationDetailsSource().buildDetails(request)
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);

        //  CRITICAL FOR CONTROLLERS
        request.setAttribute("userId", userId);
        request.setAttribute("active_role", activeRole);

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/service/EmailService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailService {

    private final JavaMailSender mailSender;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendOtpEmail(String to, String otp) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject("CrewPlay Login OTP");
        message.setText("Your OTP is: " + otp + "\nValid for 5 minutes.");
        mailSender.send(message);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/service/OtpService.java">
package in.crewplay.crewplay_backend.Auth.service;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Random;

@Service
public class OtpService {

    private final StringRedisTemplate redisTemplate;
    private static final int OTP_TTL_MINUTES = 5;

    public OtpService(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public String generateAndStoreOtp(String email) {
        String otp = String.valueOf(100000 + new Random().nextInt(900000));
        redisTemplate.opsForValue()
                .set("otp:" + email, otp, Duration.ofMinutes(OTP_TTL_MINUTES));
        return otp;
    }

    public boolean verifyOtp(String email, String otp) {
        String key = "otp:" + email;
        String storedOtp = redisTemplate.opsForValue().get(key);

        if (storedOtp != null && storedOtp.equals(otp)) {
            redisTemplate.delete(key); // one-time use
            return true;
        }
        return false;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtTokenParser.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.List;

@Component
public class JwtTokenParser {

    @Value("${jwt.secret}")
    private String secret;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    //  VALIDATE TOKEN SAFELY
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException |
                 MalformedJwtException |
                 ExpiredJwtException |
                 IllegalArgumentException e) {

            // In real prod  use logger
            System.out.println("Invalid JWT: " + e.getMessage());
            return false;
        }
    }

    private Claims getAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public Long extractUserId(String token) {
        return Long.parseLong(getAllClaims(token).getSubject());
    }

    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        return (List<String>) getAllClaims(token).get("roles");
    }

    public String extractActiveRole(String token) {
        return (String) getAllClaims(token).get("active_role");
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Auth/util/JwtUtil.java">
package in.crewplay.crewplay_backend.Auth.util;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Long userId, List<String> roles, String activeRole) {
        return Jwts.builder()
                .setSubject(String.valueOf(userId))
                .claim("roles", roles)
                .claim("active_role", activeRole)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/MatchStatus.java">
package in.crewplay.crewplay_backend.common.enums;

public class MatchStatus {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/PlayerAddMethod.java">
package in.crewplay.crewplay_backend.common.enums;

public enum PlayerAddMethod {
    MOBILE_NUMBER,
    TEAM_CODE,
    MANUAL_GUEST
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/PlayingRole.java">
package in.crewplay.crewplay_backend.common.enums;

public class PlayingRole {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/enums/TeamVisibility.java">
package in.crewplay.crewplay_backend.common.enums;

public class TeamVisibility {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/common/GlobalExceptionHandler.java">
package in.crewplay.crewplay_backend.common;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationErrors(
            MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors()
                .forEach(err -> errors.put(err.getField(), err.getDefaultMessage()));

        return ResponseEntity.badRequest().body(errors);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/config/SecurityConfig.java">
package in.crewplay.crewplay_backend.config;


import in.crewplay.crewplay_backend.Auth.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity //  REQUIRED for @PreAuthorize
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http
                .csrf(csrf -> csrf.disable())
                .formLogin(form -> form.disable())
                .httpBasic(basic -> basic.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .anyRequest().authenticated()
                );

        http.addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
        );

        return http.build();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/CrewplayBackendApplication.java">
package in.crewplay.crewplay_backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CrewplayBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(CrewplayBackendApplication.class, args);
	}




}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BallType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BallType {
    TENNIS,
    LEATHER,
    CORK,
    STUMPER

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BattingHand.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BattingHand {
    LEFT,
    RIGHT
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/BowlingType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum BowlingType {

        RIGHT_ARM_FAST,
        RIGHT_ARM_FAST_MEDIUM,
        RIGHT_ARM_MEDIUM,
        RIGHT_ARM_OFF_SPIN,
        RIGHT_ARM_LEG_SPIN,

        LEFT_ARM_FAST,
        LEFT_ARM_MEDIUM,
        LEFT_ARM_ORTHODOX,
        LEFT_ARM_WRIST_SPIN

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.SubmitSquadRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchController {

    private final MatchService matchService;

    /**
     *  SINGLE ENTRY POINT  PHASE-0
     * Called ONLY when scorer clicks "Start Match"
     *
     * Flow:
     * UI navigation (Quick Match, Select Teams, Select Squads)  frontend only
     * Final "Proceed" button  THIS API
     */
    @PostMapping("/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Match> startMatch(
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody SubmitSquadRequest request
    ) {
        Match match = matchService.startMatch(scorerUserId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchRoleController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchRoleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchRoleController {

    private final MatchRoleService matchRoleService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}/assign-roles")
    public ResponseEntity<?> assignRoles(
            @PathVariable Long matchId,
            @Valid @RequestBody AssignSquadRolesRequest request
    ) {
        matchRoleService.assignRoles(matchId, request);
        return ResponseEntity.ok().build();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/MatchSpecsController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.service.MatchSpecsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/specs")
@RequiredArgsConstructor
public class MatchSpecsController {

    private final MatchSpecsService matchSpecsService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applySpecs(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody MatchSpecsRequest request
    ) {
        Match match = matchSpecsService.applySpecs(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/controller/TossController.java">
package in.crewplay.crewplay_backend.domain.match.controller;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.service.TossService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/match/toss")
@RequiredArgsConstructor
public class TossController {

    private final TossService tossService;

    @PreAuthorize("hasRole('SCORER')")
    @PostMapping("/{matchId}")
    public ResponseEntity<Match> applyToss(
            @RequestAttribute("userId") Long scorerUserId,
            @PathVariable Long matchId,
            @Valid @RequestBody TossRequest request
    ) {
        Match match = tossService.applyToss(scorerUserId, matchId, request);
        return ResponseEntity.ok(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/AssignSquadRolesRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class AssignSquadRolesRequest {

    @NotNull
    private Long teamId;

    @NotEmpty
    private List<SquadRoleDTO> roles;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/MatchSpecsRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.BallType;
import in.crewplay.crewplay_backend.domain.match.MatchType;
import in.crewplay.crewplay_backend.domain.match.PitchType;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MatchSpecsRequest {

    @NotNull
    private MatchType matchType;

    @NotNull
    private BallType ballType;

    @NotNull
    private PitchType pitchType;

    @NotNull
    @Positive
    private Integer overs;

    private String city; // optional override
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadPlayerDTO {

    @NotNull
    private Long userId;

    private boolean captain;
    private boolean wicketKeeper;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SquadRoleDTO.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SquadRoleDTO {

    @NotNull
    private Long userId;

    private boolean captain;

    private boolean wicketKeeper;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/SubmitSquadRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class SubmitSquadRequest {

    @NotNull
    private Long teamAId;

    @NotNull
    private Long teamBId;

    @NotEmpty
    private List<SquadPlayerDTO> teamA;

    @NotEmpty
    private List<SquadPlayerDTO> teamB;

    // Optional in Phase-0
    private String city;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/dto/TossRequest.java">
package in.crewplay.crewplay_backend.domain.match.dto;

import in.crewplay.crewplay_backend.domain.match.TossDecision;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TossRequest {

    @NotNull
    private Long tossWinnerTeamId;

    @NotNull
    private TossDecision decision;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/controller/InningsController.java">
package in.crewplay.crewplay_backend.domain.match.innings.controller;

import in.crewplay.crewplay_backend.domain.match.innings.dto.InningsContextResponse;
import in.crewplay.crewplay_backend.domain.match.innings.dto.StartInningsRequest;
import in.crewplay.crewplay_backend.domain.match.innings.service.InningsService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class InningsController {

    private final InningsService inningsService;

    @GetMapping("/{matchId}/innings/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<InningsContextResponse> getContext(
            @PathVariable Long matchId
    ) {
        return ResponseEntity.ok(
                inningsService.getInningsContext(matchId)
        );
    }

    @PostMapping("/{matchId}/innings/start")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> startInnings(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId,
            @Valid @RequestBody StartInningsRequest request
    ) {
        inningsService.startInnings(matchId, scorerUserId, request);
        return ResponseEntity.ok("Innings started");
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsContextResponse {

    private InningsTeamDTO battingTeam;
    private InningsTeamDTO bowlingTeam;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class InningsPlayerDTO {

    private Long userId;
    private String name;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/InningsTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class InningsTeamDTO {
    private Long teamId;
    private String teamName;
    private String logoUrl;
    private List<InningsPlayerDTO> players;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/dto/StartInningsRequest.java">
package in.crewplay.crewplay_backend.domain.match.innings.dto;

import in.crewplay.crewplay_backend.domain.match.BattingHand;
import in.crewplay.crewplay_backend.domain.match.BowlingType;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class StartInningsRequest {

    @NotNull
    private Long strikerUserId;

    @NotNull
    private Long nonStrikerUserId;

    @NotNull
    private BattingHand strikerHand;

    @NotNull
    private BattingHand nonStrikerHand;

    @NotNull
    private Long bowlerUserId;

    @NotNull
    private BowlingType bowlingType;


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/InningsStatus.java">
package in.crewplay.crewplay_backend.domain.match.innings;

public enum InningsStatus {

    LIVE,
    AWAITING_NEW_BATSMAN,
    AWAITING_NEW_BOWLER,
    COMPLETED

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/MatchInnings.java">
package in.crewplay.crewplay_backend.domain.match.innings;

import in.crewplay.crewplay_backend.domain.match.BattingHand;
import in.crewplay.crewplay_backend.domain.match.BowlingType;
import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_innings")
@Getter
@Setter
public class MatchInnings {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    private int inningsNumber; // 1 or 2

    //  Score state
    private int totalRuns = 0;
    private int totalWickets = 0;

    private int currentOver = 0;
    private int currentBall = 0; // 05 (valid balls only)

    private int maxOvers; // from match specs

    //  Batting state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "striker_id")
    private User striker;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "non_striker_id")
    private User nonStriker;

    //  Bowling state
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "current_bowler_id")
    private User currentBowler;

    // Match state
    private boolean completed = false;

    @Enumerated(EnumType.STRING)
    private InningsStatus status = InningsStatus.LIVE;

    private int totalValidBalls = 0;

    private Integer target; // only for 2nd innings

    private boolean freeHit = false;
    private boolean awaitingBowlerAfterBatsman = false;

    private BattingHand strikerHand;    // e.g., "Right-hand"
    private BattingHand nonStrikerHand; // e.g., "Left-hand"
    private BowlingType bowlerType;     // e.g., "Right-arm Fast"

    private LocalDateTime createdAt = LocalDateTime.now();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "batting_team_id", nullable = false)
    private Team battingTeam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowling_team_id", nullable = false)
    private Team bowlingTeam;

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/repository/MatchInningsRepository.java">
package in.crewplay.crewplay_backend.domain.match.innings.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface MatchInningsRepository
        extends JpaRepository<MatchInnings, Long> {

    Optional<MatchInnings> findByMatch(Match match);
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/innings/service/InningsService.java">
package in.crewplay.crewplay_backend.domain.match.innings.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.innings.dto.*;
import in.crewplay.crewplay_backend.domain.match.innings.repository.MatchInningsRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class InningsService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadRepository;
    private final MatchInningsRepository matchInningsRepository;
    private final UserRepository userRepository;

    /**
     * STEP 1  Provide players for striker/bowler selection
     */
    public InningsContextResponse getInningsContext(Long matchId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Innings not available yet");
        }

        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found"));

        InningsContextResponse response = new InningsContextResponse();
        response.setBattingTeam(buildTeamDTO(battingTeam));
        response.setBowlingTeam(buildTeamDTO(bowlingTeam));

        return response;
    }

    private InningsTeamDTO buildTeamDTO(MatchTeam matchTeam) {

        InningsTeamDTO dto = new InningsTeamDTO();
        dto.setTeamId(matchTeam.getTeam().getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<InningsPlayerDTO> players = squadRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {
                    InningsPlayerDTO p = new InningsPlayerDTO();
                    p.setUserId(member.getUser().getId());
                    p.setName(member.getUser().getEmail()); // Replace later with real name
                    return p;
                })
                .toList();

        dto.setPlayers(players);
        return dto;
    }

    /**
     * STEP 2  Start innings
     */
    @Transactional
    public void startInnings(
            Long matchId,
            Long scorerUserId,
            StartInningsRequest request
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can start innings");
        }

        if (match.getStatus() != MatchStatus.TOSS_DONE) {
            throw new IllegalStateException("Match not ready for innings");
        }

        // 1. Validation for unique selections
        if (request.getStrikerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Striker and non-striker cannot be the same");
        }

        if (request.getBowlerUserId().equals(request.getStrikerUserId()) ||
                request.getBowlerUserId().equals(request.getNonStrikerUserId())) {
            throw new IllegalStateException("Bowler cannot be one of the opening batsmen");
        }

// 2. Fetch MatchTeams to validate squads
        MatchTeam battingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBattingTeamId())
                .orElseThrow(() -> new RuntimeException("Batting team not found for this match"));

        MatchTeam bowlingTeam = matchTeamRepository
                .findByMatch_IdAndTeam_Id(matchId, match.getBowlingTeamId())
                .orElseThrow(() -> new RuntimeException("Bowling team not found for this match"));

// 3. Squad Validation using correct DTO getters
        boolean strikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getStrikerUserId());

        boolean nonStrikerValid = squadRepository
                .existsByMatchTeamAndUser_Id(battingTeam, request.getNonStrikerUserId());

        boolean bowlerValid = squadRepository
                .existsByMatchTeamAndUser_Id(bowlingTeam, request.getBowlerUserId());

        if (!strikerValid || !nonStrikerValid) {
            throw new IllegalStateException("Selected batsmen must belong to the batting team squad");
        }

        if (!bowlerValid) {
            throw new IllegalStateException("Selected bowler must belong to the bowling team squad");
        }

// 4. Initialize the Innings
        MatchInnings innings = new MatchInnings();
        innings.setMatch(match);
        innings.setInningsNumber(1);

// Map User entities via References (performance efficient)
        innings.setStriker(userRepository.getReferenceById(request.getStrikerUserId()));
        innings.setNonStriker(userRepository.getReferenceById(request.getNonStrikerUserId()));
        innings.setCurrentBowler(userRepository.getReferenceById(request.getBowlerUserId()));

// Map Hands and Types
        innings.setStrikerHand(request.getStrikerHand());
        innings.setNonStrikerHand(request.getNonStrikerHand());
        innings.setBowlerType(request.getBowlingType()); // Matches DTO field 'bowlingType'

        matchInningsRepository.save(innings);

        match.setStatus(MatchStatus.LIVE);
        matchRepository.save(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/Match.java">
package in.crewplay.crewplay_backend.domain.match;

import in.crewplay.crewplay_backend.domain.teams.Team;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "matches")
@Getter
@Setter
public class Match {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "scorer_user_id", nullable = false)
    private Long scorerUserId;

    @Enumerated(EnumType.STRING)
    private MatchStatus status = MatchStatus.DRAFT;

    private String city;

    //  MATCH SPECS
    @Enumerated(EnumType.STRING)
    @Column(name = "match_type")
    private MatchType matchType;

    @Enumerated(EnumType.STRING)
    @Column(name = "ball_type")
    private BallType ballType;

    @Enumerated(EnumType.STRING)
    @Column(name = "pitch_type")
    private PitchType pitchType;

    private Integer overs;

    //  PARTICIPATING TEAMS
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_a_id", nullable = false)
    private Team teamA;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_b_id", nullable = false)
    private Team teamB;

    //  TOSS INFO
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "toss_winner_team_id")
    private Team tossWinnerTeam;

    @Enumerated(EnumType.STRING)
    @Column(name = "toss_decision")
    private TossDecision tossDecision;

    //  LIVE GAME STATE
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "batting_team_id")
    private Team battingTeam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowling_team_id")
    private Team bowlingTeam;

    //  WINNER
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "winner_team_id")
    private Team winnerTeam;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "scheduled_at")
    private LocalDateTime scheduledAt;

    //  Helper Methods 

    public boolean containsTeam(Long teamId) {
        if (teamId == null) return false;

        return (teamA != null && teamA.getId().equals(teamId)) ||
                (teamB != null && teamB.getId().equals(teamId));
    }

    public boolean isCompleted() {
        return status == MatchStatus.COMPLETED;
    }

    public boolean isLive() {
        return status == MatchStatus.LIVE;
    }

    public Long getTeamAId() {
        return teamA != null ? teamA.getId() : null;
    }

    public Long getTeamBId() {
        return teamB != null ? teamB.getId() : null;
    }

    public Long getWinnerTeamId() {
        return winnerTeam != null ? winnerTeam.getId() : null;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchSquadMember.java">
package in.crewplay.crewplay_backend.domain.match;

import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "match_squad_members",
        uniqueConstraints = @UniqueConstraint(columnNames = {"match_team_id", "user_id"})
)
@Getter
@Setter
public class MatchSquadMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "is_captain", nullable = false)
    private boolean captain = false;

    @Column(name = "is_wicket_keeper", nullable = false)
    private boolean wicketKeeper = false;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchStatus.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchStatus {


    DRAFT,                   // Squads not finalized
    READY,                   // Squads finalized
    SPECS_LOCKED,            // Match specs saved
    AWAITING_VERIFICATION,   // Waiting for team confirmations
    VERIFIED,                // Both teams confirmed
    TOSS_DONE,               // Toss completed
    LIVE,                    // Innings started
    COMPLETED ;               // Match finished

    public boolean isPreMatch() {
        return this == DRAFT ||
                this == READY ||
                this == SPECS_LOCKED ||
                this == AWAITING_VERIFICATION ||
                this == VERIFIED;
    }

    public boolean isInProgress() {
        return this == LIVE;
    }

    public boolean isFinished() {
        return this == COMPLETED;
    }
    }
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchTeam.java">
package in.crewplay.crewplay_backend.domain.match;

import in.crewplay.crewplay_backend.domain.teams.Team;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(name = "match_teams",
        uniqueConstraints = @UniqueConstraint(columnNames = {"match_id", "side"}))
@Getter
@Setter
public class MatchTeam {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    // "A" or "B"
    @Column(nullable = false)
    private String side;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/MatchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum MatchType {


    LIMITED_OVERS,
    BOX_CRICKET,
    TEST
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/PitchType.java">
package in.crewplay.crewplay_backend.domain.match;

public enum PitchType {
    GREEN,
    DUSTY,
    HARD,
    MAT
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

public interface MatchRepository extends JpaRepository<Match, Long> {

    @Query("SELECT m FROM Match m JOIN MatchTeam mt ON mt.match = m " +
            "WHERE mt.team.id = :teamId AND m.status = 'SCHEDULED' " +
            "AND m.scheduledAt > :now ORDER BY m.scheduledAt ASC LIMIT 1")
    Optional<Match> findNextUpcomingForTeam(Long teamId, LocalDateTime now);

    @Query("SELECT m FROM Match m JOIN MatchTeam mt ON mt.match = m " +
            "WHERE mt.team.id = :teamId AND m.status = 'COMPLETED' " +
            "ORDER BY m.scheduledAt DESC LIMIT :limit")
    List<Match> findRecentCompletedByTeam(Long teamId, int limit);

    @Query("SELECT m FROM Match m JOIN MatchTeam mt ON mt.match = m " +
            "WHERE mt.team.id = :teamId AND m.status = 'COMPLETED' ORDER BY m.scheduledAt DESC")
    List<Match> findCompletedByTeam(Long teamId);

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchSquadMemberRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface MatchSquadMemberRepository extends JpaRepository<MatchSquadMember, Long> {
    List<MatchSquadMember> findByMatchTeam(MatchTeam matchTeam);

    List<MatchSquadMember>
    findByMatchTeam_Match_IdAndMatchTeam_Team_Id(Long matchId, Long teamId);
    boolean existsByMatchTeam_Match_IdAndMatchTeam_Team_IdAndUser_Id(
            Long matchId,
            Long teamId,
            Long userId
    );


    boolean existsByMatchTeamAndUser_Id(MatchTeam matchTeam, Long userId);
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/repository/MatchTeamRepository.java">
package in.crewplay.crewplay_backend.domain.match.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchTeamRepository extends JpaRepository<MatchTeam, Long> {
    List<MatchTeam> findByMatch(Match match);
    List<MatchTeam> findByMatch_Id(Long matchId);

    Optional<MatchTeam> findByMatch_IdAndTeam_Id(Long matchId, Long teamId);
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/controller/ScoringController.java">
package in.crewplay.crewplay_backend.domain.match.scoring.controller;

import in.crewplay.crewplay_backend.domain.match.scoring.dto.LiveScoreResponse;
import in.crewplay.crewplay_backend.domain.match.scoring.dto.ScoreBallRequest;
import in.crewplay.crewplay_backend.domain.match.scoring.dto.ScoreBallResponse;
import in.crewplay.crewplay_backend.domain.match.scoring.service.ScoringService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/scoring")
@RequiredArgsConstructor
public class ScoringController {

    private final ScoringService scoringService;

    @PostMapping("/ball")
    public ScoreBallResponse scoreBall(
            @RequestBody ScoreBallRequest request,
            Authentication authentication
    ) {
        Long userId = (Long) authentication.getPrincipal();
        return scoringService.scoreBall(request, userId);
    }

    @GetMapping("/live/{matchId}")
    public LiveScoreResponse getLiveScore(
            @PathVariable Long matchId
    ) {
        return scoringService.getLiveScore(matchId);
    }

    @PostMapping("/replace-batsman")
    public void replaceBatsman(
            @RequestParam Long matchId,
            @RequestParam Long newBatsmanId,
            Authentication authentication
    ) {
        Long userId = (Long) authentication.getPrincipal();
        scoringService.replaceBatsman(matchId, newBatsmanId, userId);
    }

    @PostMapping("/change-bowler")
    public void changeBowler(
            @RequestParam Long matchId,
            @RequestParam Long newBowlerId,
            Authentication authentication
    ) {
        Long userId = (Long) authentication.getPrincipal();
        scoringService.changeBowler(matchId, newBowlerId, userId);
    }



}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/BowlerScore.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class BowlerScore {

    private Long userId;
    private String name;

    private int overs;
    private int balls;
    private int runsConceded;
    private int wickets;

    private double economy;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/BowlerSelectionDTO.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

public class BowlerSelectionDTO {
    private Long userId;
    private String name;
    private String profileImageUrl;
    private String bowlingFigures; // 2-0-12-2
    private double economy;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/EndOverResponse.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class EndOverResponse {
    private int overNumber;

    private List<String> ballsInOver;

    private int runsInOver;
    private int wicketsInOver;
    private String chaseEquation;
    private int extrasInOver;

    private int totalRuns;
    private int totalWickets;

    private double currentRunRate;

    private Integer target;
    private Integer runsRequired;
    private Integer ballsRemaining;
    private Double requiredRunRate;

    private BowlerScore bowlerSummary;

    private PlayerScore striker;
    private PlayerScore nonStriker;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/LiveScoreResponse.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class LiveScoreResponse {

    private String location;

    private int totalRuns;
    private int totalWickets;

    private String oversDisplay;

    private Integer target;
    private Integer runsRequired;

    private Double requiredRunRate;
    private Double currentRunRate;

    private PlayerScore striker;
    private PlayerScore nonStriker;

    private BowlerScore currentBowler;

    private List<String> currentOverBalls;

    private boolean freeHit;


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/PlayerScore.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PlayerScore {

    private Long userId;
    private String name;

    private int runs;
    private int balls;
    private double strikeRate;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/PlayerSelectionDTO.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

public class PlayerSelectionDTO {
    private Long userId;
    private String name;
    private String profileImageUrl;
    private boolean isWicketKeeper;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/ScoreBallRequest.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import in.crewplay.crewplay_backend.domain.match.BattingHand;
import in.crewplay.crewplay_backend.domain.match.BowlingType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.ExtraType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ScoreBallRequest {

    @NotNull
    private Long matchId;

    @NotNull
    private Long strikerId;

    @NotNull
    private Long bowlerId;

    //  ADD THESE FIELDS TO FIX THE ERRORS 
    private BattingHand strikerHand;
    private BattingHand nonStrikerHand;
    private BowlingType bowlingType;

    @NotNull
    private BallResultType ballResultType;

    private int runsOffBat = 0;

    private int extraRuns = 0;

    private ExtraType extraType;

    private boolean wicket = false; // Note: Lombok generates 'isWicket()' for booleans

    private WicketType wicketType;



    private WicketRequest wicketDetails;

    private Long dismissedPlayerId;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/ScoreBallResponse.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ScoreBallResponse {
    private LiveScoreResponse liveScore;

    private EndOverResponse endOverResponse;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/dto/WicketRequest.java">
package in.crewplay.crewplay_backend.domain.match.scoring.dto;

import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import lombok.Getter;
import lombok.Setter;


@Getter
@Setter
public class WicketRequest {
    private WicketType wicketType;

    private Long dismissedPlayerId;

    private Long fielderId;

    private Boolean isDirectHit;

    private Integer runsCompletedBeforeWicket;

    private BallResultType deliveryType;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/BallEvent.java">
package in.crewplay.crewplay_backend.domain.match.scoring.entity;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.ExtraType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "ball_events")
@Getter
@Setter
public class BallEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "innings_id", nullable = false)
    private MatchInnings innings;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowler_id", nullable = false)
    private User bowler;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "batsman_id", nullable = false)
    private User batsman;

    // Over tracking
    private int overNumber;
    private int ballNumber; // only for valid deliveries

    // Core ball classification
    @Enumerated(EnumType.STRING)
    private BallResultType ballResultType;

    // Runs
    private int runsOffBat = 0;
    private int extraRuns = 0;

    // Extras classification
    @Enumerated(EnumType.STRING)
    private ExtraType extraType;

    private boolean isUndone = false;

    // Wicket
    private boolean isWicket = false;



    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dismissed_player_id")
    private User dismissedPlayer;

    // For CAUGHT / RUN OUT / STUMPED
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "fielder_id")
    private User fielder;


    @Enumerated(EnumType.STRING)
    private WicketType wicketType;


    // For RUN OUT
    private Boolean isDirectHit;
    private Integer runsCompletedBeforeWicket;

    // Store delivery classification at dismissal time
    @Enumerated(EnumType.STRING)
    private BallResultType dismissalDeliveryType;

    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/FallOfWicket.java">
package in.crewplay.crewplay_backend.domain.match.scoring.entity;

import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(name = "fall_of_wickets")
@Getter
@Setter
public class FallOfWicket {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "innings_id")
    private MatchInnings innings;

    private int wicketNumber;

    private int teamScoreAtFall;

    private int overNumber;
    private int ballNumber;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dismissed_player_id")
    private User dismissedPlayer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bowler_id")
    private User bowler;

    @Enumerated(EnumType.STRING)
    private WicketType wicketType;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/entity/WicketDetails.java">
package in.crewplay.crewplay_backend.domain.match.scoring.entity;

import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


@Entity
@Table(name = "wicket_details")
@Getter
@Setter
public class WicketDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne
    @JoinColumn(name = "ball_event_id")
    private BallEvent ballEvent;

    @Enumerated(EnumType.STRING)
    private WicketType wicketType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dismissed_player_id")
    private User dismissedPlayer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "fielder_id")
    private User fielder; // For caught/run-out

    private Boolean directHit; // For run-out

    private Integer runsCompleted; // Runs completed before run-out

    @Enumerated(EnumType.STRING)
    private BallResultType deliveryType; // NORMAL, WIDE, NO_BALL etc
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/BallResultType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum BallResultType {

    NORMAL,      // Valid delivery
    WIDE,
    NO_BALL,
    DEAD_BALL
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/ExtraType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum ExtraType {
    WIDE,
    NO_BALL,
    BYE,
    LEG_BYE,
    PENALTY,
    NONE
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/enums/WicketType.java">
package in.crewplay.crewplay_backend.domain.match.scoring.enums;

public enum WicketType {
    BOWLED,
    LBW,
    HIT_WICKET,
    CAUGHT,
    RUN_OUT,
    STUMPED,
    RETIRED_OUT,
    OBSTRUCTING_FIELD,
    RETIRED_HURT
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/repository/BallEventRepository.java">
package in.crewplay.crewplay_backend.domain.match.scoring.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.entity.BallEvent;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface BallEventRepository
        extends JpaRepository<BallEvent, Long> {

    // Last 6 balls (excluding undone)
    List<BallEvent> findTop6ByInningsAndIsUndoneFalseOrderByIdDesc(
            MatchInnings innings
    );

    // Last valid ball (excluding undone)
    BallEvent findTopByInningsAndIsUndoneFalseOrderByIdDesc(
            MatchInnings innings
    );

    // Last undone ball (for redo)
    BallEvent findTopByInningsAndIsUndoneTrueOrderByIdDesc(
            MatchInnings innings
    );

    // ---------------- Batsman Stats ----------------

    @Query("""
        SELECT COALESCE(SUM(b.runsOffBat), 0)
        FROM BallEvent b
        WHERE b.batsman.id = :playerId
        AND b.innings.id = :inningsId
        AND b.isUndone = false
    """)
    int sumRunsByBatsman(
            @Param("playerId") Long playerId,
            @Param("inningsId") Long inningsId
    );

    @Query("""
        SELECT COUNT(b)
        FROM BallEvent b
        WHERE b.batsman.id = :playerId
        AND b.innings.id = :inningsId
        AND b.ballResultType = 'NORMAL'
        AND b.isUndone = false
    """)
    int countBallsByBatsman(
            @Param("playerId") Long playerId,
            @Param("inningsId") Long inningsId
    );

    // ---------------- Bowler Stats ----------------

    @Query("""
        SELECT COALESCE(SUM(b.runsOffBat + b.extraRuns), 0)
        FROM BallEvent b
        WHERE b.bowler.id = :bowlerId
        AND b.innings.id = :inningsId
        AND b.isUndone = false
    """)
    int sumRunsByBowler(
            @Param("bowlerId") Long bowlerId,
            @Param("inningsId") Long inningsId
    );

    @Query("""
        SELECT COUNT(b)
        FROM BallEvent b
        WHERE b.bowler.id = :bowlerId
        AND b.innings.id = :inningsId
        AND b.ballResultType = 'NORMAL'
        AND b.isUndone = false
    """)
    int countBallsByBowler(
            @Param("bowlerId") Long bowlerId,
            @Param("inningsId") Long inningsId
    );

    @Query("""
    SELECT COUNT(b)
    FROM BallEvent b
    WHERE b.bowler.id = :bowlerId
    AND b.innings.id = :inningsId
    AND b.isWicket = true
    AND b.wicketType <> 'RUN_OUT'
    AND b.wicketType <> 'RETIRED_HURT'
""")
    int countWicketsByBowler(
            @Param("bowlerId") Long bowlerId,
            @Param("inningsId") Long inningsId
    );

    @Query("""
SELECT b
FROM BallEvent b
WHERE b.innings = :innings
AND b.overNumber = :overNumber
AND b.isUndone = false
ORDER BY b.id ASC
""")
    List<BallEvent> findLastOverBalls(
            @Param("innings") MatchInnings innings,
            @Param("overNumber") int overNumber
    );
    /**
     * Fetch all ball events for a specific match.
     * Used for match analytics, phase breakdown, score calculation.
     */
    List<BallEvent> findByMatch(Match match);

    /**
     * Fetch all balls faced by a batsman across matches.
     * Used for career-level batting statistics.
     */
    List<BallEvent> findByBatsman(User batsman);

    /**
     * Fetch all balls bowled by a bowler across matches.
     * Used for career-level bowling statistics.
     */
    List<BallEvent> findByBowler(User bowler);

    /**
     * Fetch balls faced by a batsman in a specific match.
     * Used for match-specific performance stats.
     */
    List<BallEvent> findByMatchAndBatsman(Match match, User batsman);

    /**
     * Fetch balls bowled by a bowler in a specific match.
     * Used for match-specific bowling analytics.
     */
    List<BallEvent> findByMatchAndBowler(Match match, User bowler);

    List<BallEvent> findByMatch_IdIn(List<Long> matchIds);


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/repository/FallOfWicketRepository.java">
package in.crewplay.crewplay_backend.domain.match.scoring.repository;

import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.scoring.entity.FallOfWicket;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface FallOfWicketRepository
        extends JpaRepository<FallOfWicket, Long> {

    List<FallOfWicket> findByInningsOrderByWicketNumberAsc(
            MatchInnings innings
    );
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/scoring/service/ScoringService.java">
package in.crewplay.crewplay_backend.domain.match.scoring.service;


import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.innings.InningsStatus;
import in.crewplay.crewplay_backend.domain.match.innings.MatchInnings;
import in.crewplay.crewplay_backend.domain.match.innings.repository.MatchInningsRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.scoring.dto.WicketRequest;
import in.crewplay.crewplay_backend.domain.match.scoring.dto.*;
import in.crewplay.crewplay_backend.domain.match.scoring.entity.BallEvent;
import in.crewplay.crewplay_backend.domain.match.scoring.entity.FallOfWicket;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.BallResultType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.ExtraType;
import in.crewplay.crewplay_backend.domain.match.scoring.enums.WicketType;
import in.crewplay.crewplay_backend.domain.match.scoring.repository.BallEventRepository;
import in.crewplay.crewplay_backend.domain.match.scoring.repository.FallOfWicketRepository;
import in.crewplay.crewplay_backend.domain.teams.repository.TeamPlayerRepository;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

import static java.lang.Math.round;

@Service
@RequiredArgsConstructor
public class ScoringService {

    private final MatchRepository matchRepository;
    private final MatchInningsRepository inningsRepository;
    private final BallEventRepository ballEventRepository;
    private final UserRepository userRepository;
    private final FallOfWicketRepository fallOfWicketRepository;
    private final TeamPlayerRepository teamPlayerRepository;


    @Transactional
    public ScoreBallResponse scoreBall(ScoreBallRequest request, Long scorerUserId) {




        Match match = matchRepository.findById(request.getMatchId())
                .orElseThrow(() -> new RuntimeException("Match not found"));



        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can score");
        }

        if (match.getStatus() != MatchStatus.LIVE) {
            throw new IllegalStateException("Match not live");
        }

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        // ---------------- STATE VALIDATION ----------------

        if (innings.getStatus() == InningsStatus.COMPLETED) {
            throw new IllegalStateException("Innings already completed");
        }

        if (innings.getStatus() != InningsStatus.LIVE) {
            throw new IllegalStateException("Innings not in LIVE state");
        }

// Striker must exist
        if (innings.getStriker() == null) {
            throw new IllegalStateException("Striker not selected");
        }

// Bowler must exist
        if (innings.getCurrentBowler() == null) {
            throw new IllegalStateException("Bowler not selected");
        }

// Validate striker ID
        if (!innings.getStriker().getId().equals(request.getStrikerId())) {
            throw new IllegalStateException("Invalid striker");
        }

// Validate bowler ID
        if (!innings.getCurrentBowler().getId().equals(request.getBowlerId())) {
            throw new IllegalStateException("Invalid bowler");
        }

        //  Validate striker belongs to batting team
        if (!teamPlayerRepository.existsByTeamIdAndUserId(
                match.getBattingTeamId(),
                request.getStrikerId()
        )) {
            throw new IllegalStateException("Striker must belong to batting team");
        }

//  Validate non-striker belongs to batting team
        if (!teamPlayerRepository.existsByTeamIdAndUserId(
                match.getBattingTeamId(),
                innings.getNonStriker().getId()
        )) {
            throw new IllegalStateException("Non-striker must belong to batting team");
        }

//  Validate bowler belongs to bowling team
        if (!teamPlayerRepository.existsByTeamIdAndUserId(
                match.getBowlingTeamId(),
                request.getBowlerId()
        )) {
            throw new IllegalStateException("Bowler must belong to bowling team");
        }

        // ---------------- BASIC NUMERIC VALIDATION ----------------

        if (request.getRunsOffBat() < 0) {
            throw new IllegalStateException("Runs off bat cannot be negative");
        }

        if (request.getExtraRuns() < 0) {
            throw new IllegalStateException("Extra runs cannot be negative");
        }

// ---------------- WIDE VALIDATION ----------------

        if (request.getBallResultType() == BallResultType.WIDE) {

            if (request.getRunsOffBat() != 0) {
                throw new IllegalStateException("Runs off bat not allowed on wide");
            }

            if (request.getExtraRuns() < 1) {
                throw new IllegalStateException("Wide must have at least 1 extra run");
            }

            if (request.getWicketDetails() != null &&
                    request.getWicketDetails().getWicketType() != WicketType.RUN_OUT) {
                throw new IllegalStateException("Only run-out allowed on wide");
            }
        }

        // ---------------- BASIC RUN VALIDATION ----------------
        if (request.getRunsOffBat() < 0) {
            throw new IllegalStateException("Runs off bat cannot be negative");
        }

        if (request.getExtraRuns() < 0) {
            throw new IllegalStateException("Extra runs cannot be negative");
        }

// ---------------- WIDE RULES ----------------
        if (request.getBallResultType() == BallResultType.WIDE) {

            if (request.getRunsOffBat() > 0) {
                throw new IllegalStateException("Runs off bat not allowed on wide");
            }

            if (request.getExtraRuns() <= 0) {
                throw new IllegalStateException("Wide must have at least 1 extra run");
            }

            if (request.getExtraType() != null &&
                    request.getExtraType() != ExtraType.NONE) {
                throw new IllegalStateException("Wide cannot have bye or leg-bye");
            }
        }

// ---------------- NO BALL RULES ----------------
        if (request.getBallResultType() == BallResultType.NO_BALL) {

            if (request.getExtraRuns() < 1) {
                throw new IllegalStateException("No ball must have at least 1 extra run");
            }

            // If runs off bat > 0, it cannot be bye
            if (request.getRunsOffBat() > 0 &&
                    request.getExtraType() == ExtraType.BYE) {
                throw new IllegalStateException("Cannot have runs off bat and bye together");
            }

            // If runs off bat > 0, it cannot be leg-bye
            if (request.getRunsOffBat() > 0 &&
                    request.getExtraType() == ExtraType.LEG_BYE) {
                throw new IllegalStateException("Cannot have runs off bat and leg-bye together");
            }
        }

// ---------------- NORMAL DELIVERY RULES ----------------
        if (request.getBallResultType() == BallResultType.NORMAL) {

            if (request.getExtraType() == ExtraType.BYE ||
                    request.getExtraType() == ExtraType.LEG_BYE) {

                if (request.getRunsOffBat() > 0) {
                    throw new IllegalStateException(
                            "Cannot combine runs off bat with bye/leg-bye"
                    );
                }
            }
        }

// ---------------- DEAD BALL RULE ----------------
        if (request.getBallResultType() == BallResultType.DEAD_BALL) {

            if (request.getRunsOffBat() > 0 ||
                    request.getExtraRuns() > 0) {
                throw new IllegalStateException(
                        "Dead ball cannot have runs"
                );
            }

            if (request.isWicket()) {
                throw new IllegalStateException(
                        "Dead ball cannot have wicket"
                );
            }
        }

// ---------------- NO BALL VALIDATION ----------------

        if (request.getBallResultType() == BallResultType.NO_BALL) {

            if (request.getExtraRuns() < 1) {
                throw new IllegalStateException("No ball must have at least 1 extra run");
            }

            if (request.getWicketDetails() != null &&
                    request.getWicketDetails().getWicketType() != WicketType.RUN_OUT) {
                throw new IllegalStateException("Only run-out allowed on no-ball");
            }
        }

// ---------------- DEAD BALL VALIDATION ----------------

        if (request.getBallResultType() == BallResultType.DEAD_BALL) {

            if (request.getRunsOffBat() > 0 || request.getExtraRuns() > 0) {
                throw new IllegalStateException("Dead ball cannot have runs");
            }

            if (request.getWicketDetails() != null) {
                throw new IllegalStateException("Dead ball cannot have wicket");
            }
        }

// ---------------- RUN OUT LOGIC VALIDATION ----------------

        if (request.getWicketDetails() != null &&
                request.getWicketDetails().getWicketType() == WicketType.RUN_OUT) {

            Integer completedRuns = request.getWicketDetails().getRunsCompletedBeforeWicket();

            if (completedRuns == null) {
                throw new IllegalStateException("Run out must specify runsCompletedBeforeWicket");
            }

            if (completedRuns < 0) {
                throw new IllegalStateException("Completed runs cannot be negative");
            }

            if (completedRuns > request.getRunsOffBat()) {
                throw new IllegalStateException("Completed runs cannot exceed runsOffBat");
            }
        }

        BallEvent event = buildBallEvent(request, match, innings);

        if (request.getWicketDetails() != null) {
            processWicket(request.getWicketDetails(), event, innings, match);
        }

        boolean overCompleted = applyScoringLogic(event, innings, match);
        validateOverIntegrity(innings);

        ballEventRepository.save(event);
        inningsRepository.save(innings);
        matchRepository.save(match);

        ScoreBallResponse response = new ScoreBallResponse();
        response.setLiveScore(getLiveScore(match.getId()));

        if (overCompleted) {
            response.setEndOverResponse(buildEndOverResponse(match, innings));
        }

        return response;
    }

    private BallEvent buildBallEvent(
            ScoreBallRequest request,
            Match match,
            MatchInnings innings
    ) {

        BallEvent event = new BallEvent();

        event.setMatch(match);
        event.setInnings(innings);
        event.setBowler(userRepository.getReferenceById(request.getBowlerId()));
        event.setBatsman(userRepository.getReferenceById(request.getStrikerId()));

        event.setBallResultType(request.getBallResultType());
        event.setRunsOffBat(request.getRunsOffBat());
        event.setExtraRuns(request.getExtraRuns());
        event.setExtraType(request.getExtraType());
        event.setWicket(request.isWicket());
        event.setWicketType(request.getWicketType());

        if (request.getDismissedPlayerId() != null) {
            event.setDismissedPlayer(
                    userRepository.getReferenceById(request.getDismissedPlayerId())
            );
        }

        event.setOverNumber(innings.getCurrentOver());
        event.setBallNumber(innings.getCurrentBall());

        return event;
    }

    private boolean applyScoringLogic(
            BallEvent event,
            MatchInnings innings,
            Match match) {

        int runsThisBall;

// Retired hurt must not affect score
        if (event.getWicketType() == WicketType.RETIRED_HURT) {
            runsThisBall = 0;
        }
        else if (event.isWicket()
                && event.getWicketType() == WicketType.RUN_OUT
                && event.getRunsCompletedBeforeWicket() != null) {

            runsThisBall = event.getRunsCompletedBeforeWicket()
                    + event.getExtraRuns();
        }
        else {
            runsThisBall = event.getRunsOffBat()
                    + event.getExtraRuns();
        }

        if (event.isWicket()
                && event.getWicketType() == WicketType.RUN_OUT
                && event.getRunsCompletedBeforeWicket() != null) {

            // Run-out special case
            runsThisBall = event.getRunsCompletedBeforeWicket()
                    + event.getExtraRuns();

        } else {
            runsThisBall = event.getRunsOffBat()
                    + event.getExtraRuns();
        }

        innings.setTotalRuns(
                innings.getTotalRuns() + runsThisBall
        );

        boolean overCompleted = false;

        switch (event.getBallResultType()) {

            case NORMAL:
                innings.setCurrentBall(innings.getCurrentBall() + 1);
                innings.setTotalValidBalls(innings.getTotalValidBalls() + 1);

                int runsForStrike;

                if (event.isWicket()
                        && event.getWicketType() == WicketType.RUN_OUT
                        && event.getRunsCompletedBeforeWicket() != null) {

                    runsForStrike = event.getRunsCompletedBeforeWicket();
                } else {
                    runsForStrike = event.getRunsOffBat();
                }

                if (runsForStrike % 2 == 1) {
                    swapStrike(innings);
                }

                if (innings.getCurrentBall() == 6) {

                    boolean wicketFell = event.isWicket();

                    innings.setCurrentOver(innings.getCurrentOver() + 1);
                    innings.setCurrentBall(0);
                    swapStrike(innings);

                    if (wicketFell) {
                        // First wait for batsman
                        innings.setStatus(InningsStatus.AWAITING_NEW_BATSMAN);
                        innings.setAwaitingBowlerAfterBatsman(true);
                    } else {
                        innings.setStatus(InningsStatus.AWAITING_NEW_BOWLER);
                    }

                    overCompleted = true;
                }
                break;

            case WIDE:
                handleWide(event, innings);
                break;

            case NO_BALL:
                handleNoBall(event, innings);
                break;

            case DEAD_BALL:
                return false;
        }



        // ---------------- CHASE COMPLETION ----------------
        if (innings.getTarget() != null) {

            if (innings.getTotalRuns() >= innings.getTarget()) {

                innings.setStatus(InningsStatus.COMPLETED);
                match.setStatus(MatchStatus.COMPLETED);

                // Hard lock: prevent further over processing
                return false;
            }

            // Defensive: score must never exceed target + current ball runs
            int maxAllowed = innings.getTarget() + 6;
            // 6 is max possible in one legal ball

            if (innings.getTotalRuns() > maxAllowed) {
                throw new IllegalStateException("Score exceeds logical target bounds");
            }
        }

        // ---------------- MAX OVER COMPLETION ----------------
        if (innings.getTarget() == null &&
                innings.getCurrentOver() >= innings.getMaxOvers()) {

            completeInnings(innings, match);
        }

        if (event.getBallResultType() == BallResultType.NORMAL) {
            innings.setFreeHit(false);
        }

        return overCompleted;
    }
    private void swapStrike(MatchInnings innings) {

        User temp = innings.getStriker();
        innings.setStriker(innings.getNonStriker());
        innings.setNonStriker(temp);
    }

    private void processWicket(
            WicketRequest wicketRequest,
            BallEvent event,
            MatchInnings innings,
            Match match
    ) {

        event.setWicket(true);
        event.setWicketType(wicketRequest.getWicketType());

        Long strikerId = innings.getStriker().getId();
        Long nonStrikerId = innings.getNonStriker().getId();

        //  Validate dismissed player
        if (!wicketRequest.getDismissedPlayerId().equals(strikerId)
                && !wicketRequest.getDismissedPlayerId().equals(nonStrikerId)) {
            throw new IllegalStateException("Invalid dismissed player");
        }

        User dismissed = userRepository.getReferenceById(
                wicketRequest.getDismissedPlayerId()
        );
        event.setDismissedPlayer(dismissed);

        if (wicketRequest.getFielderId() != null) {

            //  Validate fielder belongs to bowling team
            if (!teamPlayerRepository.existsByTeamIdAndUserId(
                    match.getBowlingTeamId(),
                    wicketRequest.getFielderId()
            )) {
                throw new IllegalStateException("Fielder must belong to bowling team");
            }

            event.setFielder(
                    userRepository.getReferenceById(
                            wicketRequest.getFielderId()
                    )
            );
        }

        event.setIsDirectHit(wicketRequest.getIsDirectHit());
        event.setRunsCompletedBeforeWicket(
                wicketRequest.getRunsCompletedBeforeWicket()
        );
        event.setDismissalDeliveryType(
                wicketRequest.getDeliveryType()
        );

        //  FREE HIT PROTECTION
        if (innings.isFreeHit()
                && wicketRequest.getWicketType() != WicketType.RUN_OUT) {
            event.setWicket(false);
            event.setWicketType(null);
            return;
        }

        //  RUN OUT VALIDATION
        if (wicketRequest.getWicketType() == WicketType.RUN_OUT) {
            if (wicketRequest.getRunsCompletedBeforeWicket() != null) {

                if (wicketRequest.getRunsCompletedBeforeWicket()
                        != event.getRunsOffBat()) {

                    throw new IllegalStateException(
                            "Run out runs mismatch with runsOffBat"
                    );
                }
            }
        }

        // ---------------- RETIRED HURT ----------------
        if (wicketRequest.getWicketType() == WicketType.RETIRED_HURT) {

            // Retired hurt:
            // - Does NOT count as wicket
            // - Does NOT affect bowler stats
            // - Does NOT consume ball
            // - Just replace batsman

            event.setBallResultType(BallResultType.DEAD_BALL);
            event.setWicket(false);

            innings.setStatus(InningsStatus.AWAITING_NEW_BATSMAN);
            return;
        }

        // ---------------- NORMAL WICKET ----------------
        innings.setTotalWickets(
                innings.getTotalWickets() + 1
        );

        createFallOfWicket(event, innings);

//  ALL OUT CHECK MUST COME FIRST
        if (innings.getTotalWickets() >= 10) {

            // Immediately end innings
            completeInnings(innings, match);

            return; // STOP further state changes
        }

// Normal wicket flow (not all out)
        innings.setStatus(InningsStatus.AWAITING_NEW_BATSMAN);
    }


    private void handleWide(
            BallEvent event,
            MatchInnings innings
    ) {
        // Wide does NOT count as ball

        if (event.getExtraRuns() > 1) {
            if ((event.getExtraRuns() - 1) % 2 == 1) {
                swapStrike(innings);
            }
        }
    }

    private void handleNoBall(
            BallEvent event,
            MatchInnings innings
    ) {
        // No ball does NOT count as valid delivery

        int totalRunsThisBall =
                event.getRunsOffBat()
                        + event.getExtraRuns();

        // If run out happened,
        // strike rotation depends on runs completed
        if (event.isWicket()
                && event.getWicketType() == WicketType.RUN_OUT
                && event.getRunsCompletedBeforeWicket() != null) {

            int completedRuns = event.getRunsCompletedBeforeWicket();

            if (completedRuns % 2 == 1) {
                swapStrike(innings);
            }

        } else {
            // Normal no-ball case (no wicket)
            if (event.getRunsOffBat() % 2 == 1) {
                swapStrike(innings);
            }
        }

        // Activate free hit for next legal delivery
        innings.setFreeHit(true);
    }

    private void completeInnings(MatchInnings innings, Match match) {

        innings.setStatus(InningsStatus.COMPLETED);

        if (innings.getInningsNumber() == 1) {

            Long oldBatting = match.getBattingTeamId();
            Long oldBowling = match.getBowlingTeamId();

            match.setBattingTeamId(oldBowling);
            match.setBowlingTeamId(oldBatting);

            MatchInnings second = new MatchInnings();
            second.setMatch(match);
            second.setInningsNumber(2);
            second.setMaxOvers(match.getOvers());
            second.setTarget(innings.getTotalRuns() + 1);
            second.setStatus(InningsStatus.LIVE);

            inningsRepository.save(second);

        } else {

            match.setStatus(MatchStatus.COMPLETED);
        }
    }

    @Transactional
    public void replaceBatsman(
            Long matchId,
            Long newBatsmanId,
            Long scorerUserId
    ) {
        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer allowed");
        }

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        if (innings.getStatus() == InningsStatus.COMPLETED) {
            throw new IllegalStateException("Innings already completed");
        }

        if (innings.getStatus() != InningsStatus.AWAITING_NEW_BATSMAN) {
            throw new IllegalStateException("Not waiting for new batsman");
        }

        User newBatsman = userRepository.getReferenceById(newBatsmanId);
        innings.setStriker(newBatsman);

        if (innings.isAwaitingBowlerAfterBatsman()) {
            innings.setStatus(InningsStatus.AWAITING_NEW_BOWLER);
            innings.setAwaitingBowlerAfterBatsman(false);
        } else {
            innings.setStatus(InningsStatus.LIVE);
        }

        inningsRepository.save(innings);
    }

    @Transactional
    public void changeBowler(
            Long matchId,
            Long newBowlerId,
            Long scorerUserId
    ) {
        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer allowed");
        }

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        if (innings.getStatus() == InningsStatus.COMPLETED) {
            throw new IllegalStateException("Innings already completed");
        }

        if (innings.getStatus() != InningsStatus.AWAITING_NEW_BOWLER) {
            throw new IllegalStateException("Not waiting for bowler change");
        }

        User newBowler = userRepository.getReferenceById(newBowlerId);

        if (!teamPlayerRepository.existsByTeamIdAndUserId(
                match.getBowlingTeamId(),
                newBowlerId
        )) {
            throw new IllegalStateException("Bowler must belong to bowling team");
        }
         //  Prevent consecutive overs
        if (innings.getCurrentBowler() != null &&
                innings.getCurrentBowler().getId().equals(newBowlerId)) {
            throw new IllegalStateException("Bowler cannot bowl consecutive overs");
        }

        innings.setCurrentBowler(newBowler);
        innings.setStatus(InningsStatus.LIVE);

        inningsRepository.save(innings);
    }

    @Transactional(readOnly = true)
    public LiveScoreResponse getLiveScore(Long matchId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        LiveScoreResponse response = new LiveScoreResponse();

        response.setLocation(match.getCity());
        response.setTotalRuns(innings.getTotalRuns());
        response.setTotalWickets(innings.getTotalWickets());

        response.setOversDisplay(
                innings.getCurrentOver() + "." + innings.getCurrentBall()
        );

        response.setTarget(innings.getTarget());
        response.setFreeHit(innings.isFreeHit());

        int totalBalls = innings.getTotalValidBalls();

        if (totalBalls > 0) {
            double runRate = (innings.getTotalRuns() * 6.0) / totalBalls;
            response.setCurrentRunRate(round(runRate));
        }

        if (innings.getTarget() != null) {

            int runsReq = innings.getTarget() - innings.getTotalRuns();
            response.setRunsRequired(Math.max(runsReq, 0));

            int ballsRemaining =
                    (innings.getMaxOvers() * 6) - innings.getTotalValidBalls();

            if (ballsRemaining > 0) {
                double rrr = (runsReq * 6.0) / ballsRemaining;
                response.setRequiredRunRate(round(rrr));
            }
        }

        response.setStriker(buildPlayerScore(
                innings.getStriker().getId(),
                match,
                innings
        ));

        response.setNonStriker(buildPlayerScore(
                innings.getNonStriker().getId(),
                match,
                innings
        ));

        response.setCurrentBowler(
                buildBowlerScore(
                        innings.getCurrentBowler().getId(),
                        match,
                        innings
                )
        );

        response.setCurrentOverBalls(
                ballEventRepository
                        .findTop6ByInningsAndIsUndoneFalseOrderByIdDesc(innings)
                        .stream()
                        .map(this::formatBall)
                        .toList()
        );

        return response;
    }

    private PlayerScore buildPlayerScore(
            Long playerId,
            Match match,
            MatchInnings innings
    ) {

        PlayerScore score = new PlayerScore();

        score.setUserId(playerId);
        score.setName(userRepository.findById(playerId)
                .map(User::getEmail)
                .orElse("Player"));

        int runs = ballEventRepository.sumRunsByBatsman(playerId, innings.getId());
        int balls = ballEventRepository.countBallsByBatsman(playerId, innings.getId());

        score.setRuns(runs);
        score.setBalls(balls);

        if (balls > 0) {
            score.setStrikeRate(round((runs * 100.0) / balls));
        }

        return score;
    }

    private BowlerScore buildBowlerScore(
            Long bowlerId,
            Match match,
            MatchInnings innings
    ) {

        BowlerScore score = new BowlerScore();

        score.setUserId(bowlerId);
        score.setName(userRepository.findById(bowlerId)
                .map(User::getEmail)
                .orElse("Bowler"));

        int runs = ballEventRepository.sumRunsByBowler(bowlerId, innings.getId());
        int balls = ballEventRepository.countBallsByBowler(bowlerId, innings.getId());
        int wickets = ballEventRepository.countWicketsByBowler(bowlerId, innings.getId());

        score.setRunsConceded(runs);
        score.setWickets(wickets);

        score.setOvers(balls / 6);
        score.setBalls(balls % 6);

        if (balls > 0) {
            double economy = (runs * 6.0) / balls;
            score.setEconomy(round(economy));
        }

        return score;
    }

    private double round(double value) {
        return Math.round(value * 100.0) / 100.0;
    }

    private String formatBall(BallEvent event) {

        if (event.getBallResultType() == BallResultType.WIDE) {
            return "Wd";
        }

        if (event.getBallResultType() == BallResultType.NO_BALL) {
            return "Nb";
        }

        if (event.isWicket()) {
            return "W";
        }

        if (event.getExtraType() != null) {
            switch (event.getExtraType()) {
                case BYE:
                    return "B" + event.getExtraRuns();
                case LEG_BYE:
                    return "Lb" + event.getExtraRuns();
                default:
                    break;
            }
        }

        return String.valueOf(event.getRunsOffBat());
    }

    @Transactional
    public void undoLastBall(Long matchId, Long scorerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer allowed");
        }

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        BallEvent lastBall = ballEventRepository
                .findTopByInningsAndIsUndoneFalseOrderByIdDesc(innings);

        if (lastBall == null) {
            throw new IllegalStateException("No balls to undo");
        }


        lastBall.setUndone(true);
        ballEventRepository.save(lastBall);
        reverseBallImpact(lastBall, innings, match);
        validateOverIntegrity(innings);


        inningsRepository.save(innings);
        matchRepository.save(match);
    }
    private void reverseBallImpact(
            BallEvent event,
            MatchInnings innings,
            Match match) {

        // ---------------- RUN RESTORE ----------------
        int runsThisBall;

        if (event.isWicket()
                && event.getWicketType() == WicketType.RUN_OUT
                && event.getRunsCompletedBeforeWicket() != null) {

            runsThisBall =
                    event.getRunsCompletedBeforeWicket()
                            + event.getExtraRuns();
        } else {
            runsThisBall =
                    event.getRunsOffBat()
                            + event.getExtraRuns();
        }

        innings.setTotalRuns(
                innings.getTotalRuns() - runsThisBall
        );


        // ---------------- DELIVERY RESTORE ----------------
        if (event.getBallResultType() == BallResultType.NORMAL) {

            boolean wasSixthBall =
                    event.getBallNumber() == 5;

            // Restore over & ball
            if (wasSixthBall) {
                innings.setCurrentOver(
                        innings.getCurrentOver() - 1
                );
                innings.setCurrentBall(5);

                // Reverse over-end strike swap
                swapStrike(innings);
            } else {
                innings.setCurrentBall(
                        innings.getCurrentBall() - 1
                );
            }

            innings.setTotalValidBalls(
                    innings.getTotalValidBalls() - 1
            );

            // Reverse strike for runs
            int runsForStrike =
                    event.isWicket()
                            && event.getWicketType() == WicketType.RUN_OUT
                            && event.getRunsCompletedBeforeWicket() != null
                            ? event.getRunsCompletedBeforeWicket()
                            : event.getRunsOffBat();

            if (runsForStrike % 2 == 1) {
                swapStrike(innings);
            }
        }


        // ---------------- WICKET RESTORE ----------------
        if (event.isWicket()) {

            innings.setTotalWickets(
                    innings.getTotalWickets() - 1
            );

            fallOfWicketRepository
                    .findByInningsOrderByWicketNumberAsc(innings)
                    .stream()
                    .reduce((first, second) -> second)
                    .ifPresent(fallOfWicketRepository::delete);
        }


        // ---------------- FREE HIT RESTORE ----------------
        if (event.getBallResultType() == BallResultType.NO_BALL) {

            // Undoing a no-ball removes free hit
            innings.setFreeHit(false);

        } else {

            // Fetch previous valid ball (exclude this event)
            BallEvent previous = ballEventRepository
                    .findTopByInningsAndIsUndoneFalseOrderByIdDesc(innings);

            if (previous != null
                    && previous.getBallResultType() == BallResultType.NO_BALL) {

                innings.setFreeHit(true);
            } else {
                innings.setFreeHit(false);
            }
        }


        // ---------------- STATUS RESTORE ----------------
        innings.setStatus(InningsStatus.LIVE);
        innings.setAwaitingBowlerAfterBatsman(false);

        // Restore match state only if target no longer reached
        if (innings.getTarget() != null) {
            if (innings.getTotalRuns() < innings.getTarget()) {
                match.setStatus(MatchStatus.LIVE);
                innings.setStatus(InningsStatus.LIVE);
            }
        }
    }

    private EndOverResponse buildEndOverResponse(
            Match match,
            MatchInnings innings
    ) {
        EndOverResponse response = new EndOverResponse();

        int completedOver = innings.getCurrentOver();

        response.setOverNumber(completedOver);

        // Fetch last 6 valid balls of previous over
        List<BallEvent> balls =
                ballEventRepository
                        .findLastOverBalls(innings, completedOver - 1);

        response.setBallsInOver(
                balls.stream()
                        .map(this::formatBall)
                        .toList()
        );

        int runsInOver = balls.stream()
                .mapToInt(b -> b.getRunsOffBat() + b.getExtraRuns())
                .sum();

        int wicketsInOver = (int) balls.stream()
                .filter(BallEvent::isWicket)
                .count();

        int extrasInOver = balls.stream()
                .mapToInt(BallEvent::getExtraRuns)
                .sum();

        response.setExtrasInOver(extrasInOver);

        response.setRunsInOver(runsInOver);
        response.setWicketsInOver(wicketsInOver);

        response.setTotalRuns(innings.getTotalRuns());
        response.setTotalWickets(innings.getTotalWickets());

        response.setCurrentRunRate(
                calculateRunRate(innings)
        );

        if (innings.getTarget() != null) {
            response.setTarget(innings.getTarget());
            response.setRequiredRunRate(
                    calculateRequiredRunRate(innings)
            );
            response.setChaseEquation(
                    buildChaseEquation(innings)
            );
        }

        response.setBowlerSummary(
                buildBowlerScore(
                        innings.getCurrentBowler().getId(),
                        match,
                        innings
                )
        );

        response.setStriker(
                buildPlayerScore(
                        innings.getStriker().getId(),
                        match,
                        innings
                )
        );

        response.setNonStriker(
                buildPlayerScore(
                        innings.getNonStriker().getId(),
                        match,
                        innings
                )
        );

        return response;
    }

    @Transactional
    public void redoLastBall(Long matchId, Long scorerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer allowed");
        }

        MatchInnings innings = inningsRepository.findByMatch(match)
                .orElseThrow(() -> new RuntimeException("Innings not found"));

        BallEvent lastUndone = ballEventRepository
                .findTopByInningsAndIsUndoneTrueOrderByIdDesc(innings);

        if (lastUndone == null) {
            throw new IllegalStateException("No balls to redo");
        }

        applyScoringLogic(lastUndone, innings, match);
        validateOverIntegrity(innings);

        lastUndone.setUndone(false);
        ballEventRepository.save(lastUndone);

        inningsRepository.save(innings);
        matchRepository.save(match);
    }

    private void createFallOfWicket(
            BallEvent event,
            MatchInnings innings
    ) {
        FallOfWicket fow = new FallOfWicket();

        fow.setInnings(innings);
        fow.setWicketNumber(innings.getTotalWickets());
        fow.setTeamScoreAtFall(innings.getTotalRuns());
        fow.setOverNumber(innings.getCurrentOver());
        fow.setBallNumber(innings.getCurrentBall());
        fow.setDismissedPlayer(event.getDismissedPlayer());
        fow.setBowler(event.getBowler());
        fow.setWicketType(event.getWicketType());

        fallOfWicketRepository.save(fow);
    }

    private double calculateRunRate(MatchInnings innings) {
        if (innings.getTotalValidBalls() == 0) return 0;
        return round(
                (innings.getTotalRuns() * 6.0)
                        / innings.getTotalValidBalls()
        );
    }

    private double calculateRequiredRunRate(MatchInnings innings) {
        int ballsRemaining =
                (innings.getMaxOvers() * 6)
                        - innings.getTotalValidBalls();

        if (ballsRemaining <= 0) return 0;

        int runsReq =
                innings.getTarget() - innings.getTotalRuns();

        return round((runsReq * 6.0) / ballsRemaining);
    }

    private String buildChaseEquation(MatchInnings innings) {
        int ballsRemaining =
                (innings.getMaxOvers() * 6)
                        - innings.getTotalValidBalls();

        int runsReq =
                innings.getTarget() - innings.getTotalRuns();

        return "Need "
                + runsReq
                + " runs from "
                + ballsRemaining
                + " balls";
    }

    private void validateOverIntegrity(MatchInnings innings) {

        //  Ball cannot exceed 6
        if (innings.getCurrentBall() < 0 || innings.getCurrentBall() > 6) {
            throw new IllegalStateException("Invalid ball count in over");
        }

        //  Over cannot be negative
        if (innings.getCurrentOver() < 0) {
            throw new IllegalStateException("Invalid over count");
        }

        int expectedTotalValidBalls =
                (innings.getCurrentOver() * 6)
                        + innings.getCurrentBall();

        if (innings.getTotalValidBalls() != expectedTotalValidBalls) {
            throw new IllegalStateException(
                    "Over integrity violated: totalValidBalls mismatch"
            );
        }
    }

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchRoleService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.dto.AssignSquadRolesRequest;
import in.crewplay.crewplay_backend.domain.match.dto.SquadRoleDTO;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MatchRoleService {

    private final MatchSquadMemberRepository squadMemberRepository;

    @Transactional
    public void assignRoles(Long matchId, AssignSquadRolesRequest request) {

        List<MatchSquadMember> squadMembers =
                squadMemberRepository.findByMatchTeam_Match_IdAndMatchTeam_Team_Id(
                        matchId,
                        request.getTeamId()
                );

        if (squadMembers.isEmpty()) {
            throw new IllegalStateException("No squad found for this team in the match");
        }

        Map<Long, MatchSquadMember> squadMap =
                squadMembers.stream()
                        .collect(Collectors.toMap(
                                m -> m.getUser().getId(),
                                Function.identity()
                        ));

        long captainCount =
                request.getRoles().stream()
                        .filter(SquadRoleDTO::isCaptain)
                        .count();

        if (captainCount != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }

        // Reset roles first (idempotent)
        squadMembers.forEach(m -> {
            m.setCaptain(false);
            m.setWicketKeeper(false);
        });

        // Apply new roles
        for (SquadRoleDTO dto : request.getRoles()) {

            MatchSquadMember member = squadMap.get(dto.getUserId());

            if (member == null) {
                throw new IllegalStateException(
                        "User " + dto.getUserId() + " is not part of this squad"
                );
            }

            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
        }

        squadMemberRepository.saveAll(squadMembers);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.MatchSquadMember;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.dto.SquadPlayerDTO;
import in.crewplay.crewplay_backend.domain.match.dto.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.Repository.TeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.lang.System.in;

@Service
@RequiredArgsConstructor
public class MatchService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final TeamRepository teamRepository;
    private final UserRepository userRepository;

    /**
     *  SINGLE ENTRY POINT  PHASE-0
     * Called when scorer clicks "Start Match"
     */
    @Transactional
    public Match startMatch(Long scorerId, SubmitSquadRequest request) {

        // 1 VALIDATION (Phase-0 invariants)
        validateSquads(
                request.getTeamA().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamB().stream().map(SquadPlayerDTO::getUserId).toList(),
                request.getTeamA().stream().filter(SquadPlayerDTO::isCaptain).count(),
                request.getTeamB().stream().filter(SquadPlayerDTO::isCaptain).count()
        );

        // 2 CREATE MATCH
        Match match = new Match();
        match.setScorerUserId(scorerId);
        match.setCity(request.getCity()); // optional in Phase-0
        match.setStatus(MatchStatus.READY); // NOT LIVE
        match = matchRepository.save(match);

        // 3 TEAM A + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamAId(),
                request.getTeamA(),
                "A"
        );

        // 4 TEAM B + SQUAD
        saveTeamAndSquad(
                match,
                request.getTeamBId(),
                request.getTeamB(),
                "B"
        );

        return match;
    }

    /**
     *  Phase-0 squad rules
     */
    private void validateSquads(
            List<Long> teamAPlayers,
            List<Long> teamBPlayers,
            long teamACaptains,
            long teamBCaptains
    ) {
        if (teamAPlayers.size() < 3 || teamBPlayers.size() < 3) {
            throw new IllegalStateException("Each team must have at least 3 players");
        }

        Set<Long> intersection = new HashSet<>(teamAPlayers);
        intersection.retainAll(teamBPlayers);

        if (!intersection.isEmpty()) {
            throw new IllegalStateException("Same player cannot play for both teams");
        }

        if (teamACaptains != 1 || teamBCaptains != 1) {
            throw new IllegalStateException("Each team must have exactly one captain");
        }
    }

    /**
     *  Helper  persists MatchTeam + MatchSquadMembers
     */
    private void saveTeamAndSquad(
            Match match,
            Long teamId,
            List<SquadPlayerDTO> players,
            String side
    ) {
        // Create MatchTeam
        MatchTeam matchTeam = new MatchTeam();
        matchTeam.setMatch(match);
        matchTeam.setTeam(teamRepository.getReferenceById(teamId));
        matchTeam.setSide(side);
        matchTeam = matchTeamRepository.save(matchTeam);

        // Save squad members
        for (SquadPlayerDTO dto : players) {
            MatchSquadMember member = new MatchSquadMember();
            member.setMatchTeam(matchTeam);
            member.setUser(userRepository.getReferenceById(dto.getUserId()));
            member.setCaptain(dto.isCaptain());
            member.setWicketKeeper(dto.isWicketKeeper());
            squadMemberRepository.save(member);
        }
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/MatchSpecsService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchStatus;
import in.crewplay.crewplay_backend.domain.match.dto.MatchSpecsRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MatchSpecsService {

    private final MatchRepository matchRepository;

    @Transactional
    public Match applySpecs(Long scorerUserId, Long matchId, MatchSpecsRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        //  Ensure only creator scorer can modify
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("You are not allowed to modify this match");
        }

        //  Allow specs only if match is in READY or DRAFT
        if (match.getStatus() != MatchStatus.READY &&
                match.getStatus() != MatchStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify specs after match started");
        }

        //  Apply specs
        match.setMatchType(request.getMatchType());
        match.setBallType(request.getBallType());
        match.setPitchType(request.getPitchType());
        match.setOvers(request.getOvers());

        if (request.getCity() != null && !request.getCity().isBlank()) {
            match.setCity(request.getCity());
        }

        //  Move status forward
        match.setStatus(MatchStatus.SPECS_LOCKED);

        return matchRepository.save(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/service/TossService.java">
package in.crewplay.crewplay_backend.domain.match.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.dto.TossRequest;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TossService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;

    @Transactional
    public Match applyToss(Long scorerUserId, Long matchId, TossRequest request) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new IllegalStateException("Match not found"));

        //  Ownership check
        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Not allowed");
        }

        //  Must be VERIFIED now (NOT SPECS_LOCKED)
        if (match.getStatus() != MatchStatus.VERIFIED) {
            throw new IllegalStateException("Toss allowed only after verification");
        }

        //  Fetch match teams
        List<MatchTeam> teams = matchTeamRepository.findByMatch_Id(matchId);
        if (teams.size() != 2) {
            throw new IllegalStateException("Match teams not properly initialized");
        }

        MatchTeam teamA = teams.get(0);
        MatchTeam teamB = teams.get(1);

        boolean validTeam =
                teamA.getTeam().getId().equals(request.getTossWinnerTeamId()) ||
                        teamB.getTeam().getId().equals(request.getTossWinnerTeamId());

        if (!validTeam) {
            throw new IllegalStateException("Invalid toss winner");
        }

        //  Apply toss
        match.setTossWinnerTeamId(request.getTossWinnerTeamId());
        match.setTossDecision(request.getDecision());

        Long battingTeamId;
        Long bowlingTeamId;

        if (request.getDecision() == TossDecision.BAT) {
            battingTeamId = request.getTossWinnerTeamId();
        } else {
            battingTeamId =
                    teamA.getTeam().getId().equals(request.getTossWinnerTeamId())
                            ? teamB.getTeam().getId()
                            : teamA.getTeam().getId();
        }

        bowlingTeamId =
                teamA.getTeam().getId().equals(battingTeamId)
                        ? teamB.getTeam().getId()
                        : teamA.getTeam().getId();

        match.setBattingTeamId(battingTeamId);
        match.setBowlingTeamId(bowlingTeamId);

        //  IMPORTANT: Move to TOSS_DONE (NOT LIVE)
        match.setStatus(MatchStatus.TOSS_DONE);

        return matchRepository.save(match);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/TossDecision.java">
package in.crewplay.crewplay_backend.domain.match;

public enum TossDecision {

    BAT,
    BOWL

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/controller/MatchVerificationController.java">
package in.crewplay.crewplay_backend.domain.match.verification.controller;

import in.crewplay.crewplay_backend.domain.match.verification.dto.VerificationContextResponse;
import in.crewplay.crewplay_backend.domain.match.verification.service.MatchVerificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/matches")
@RequiredArgsConstructor
public class MatchVerificationController {

    private final MatchVerificationService verificationService;

    @GetMapping("/{matchId}/verification/context")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<VerificationContextResponse> getContext(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long scorerUserId
    ) {

        return ResponseEntity.ok(
                verificationService.getVerificationContext(matchId, scorerUserId)
        );
    }

    @PostMapping("/{matchId}/verification/send")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<?> sendVerification(
            @PathVariable Long matchId,
            @RequestParam Long matchTeamId,
            @RequestParam Long selectedUserId,
            @RequestAttribute("userId") Long scorerUserId
    ) {
        verificationService.sendVerificationRequest(
                scorerUserId,
                matchId,
                matchTeamId,
                selectedUserId
        );
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/accept")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> accept(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.acceptVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{matchId}/verification/reject")
    @PreAuthorize("hasRole('PLAYER')")
    public ResponseEntity<?> reject(
            @PathVariable Long matchId,
            @RequestAttribute("userId") Long userId
    ) {
        verificationService.rejectVerification(matchId, userId);
        return ResponseEntity.ok().build();
    }


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationContextResponse.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationContextResponse {

    private VerificationTeamDTO teamA;
    private VerificationTeamDTO teamB;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationPlayerDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerificationPlayerDTO {

    private Long userId;
    private String name;
    private boolean isGuest;
    private boolean isScorer;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/dto/VerificationTeamDTO.java">
package in.crewplay.crewplay_backend.domain.match.verification.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class VerificationTeamDTO {

    private Long matchTeamId;
    private String teamName;
    private String logoUrl;
    private List<VerificationPlayerDTO> players;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerification.java">
package in.crewplay.crewplay_backend.domain.match.verification;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "match_verifications")
@Getter
@Setter
public class MatchVerification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Which match
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    // Team side (A / B)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "match_team_id", nullable = false)
    private MatchTeam matchTeam;

    // Selected verifier (must be registered user)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "verifier_user_id", nullable = false)
    private User verifier;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MatchVerificationStatus status = MatchVerificationStatus.PENDING;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "responded_at")
    private LocalDateTime respondedAt;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/MatchVerificationStatus.java">
package in.crewplay.crewplay_backend.domain.match.verification;

public enum MatchVerificationStatus {
    PENDING,
    VERIFIED,
    REJECTED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/repository/MatchVerificationRepository.java">
package in.crewplay.crewplay_backend.domain.match.verification.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.MatchTeam;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface MatchVerificationRepository extends JpaRepository<MatchVerification, Long> {

    Optional<MatchVerification> findByMatchAndMatchTeam(Match match, MatchTeam matchTeam);

    List<MatchVerification> findByMatch(Match match);

    boolean existsByMatchAndStatus(Match match, MatchVerificationStatus status);
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/match/verification/service/MatchVerificationService.java">
package in.crewplay.crewplay_backend.domain.match.verification.service;

import in.crewplay.crewplay_backend.domain.match.*;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchTeamRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchSquadMemberRepository;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerification;
import in.crewplay.crewplay_backend.domain.match.verification.MatchVerificationStatus;
import in.crewplay.crewplay_backend.domain.match.verification.dto.*;
import in.crewplay.crewplay_backend.domain.match.verification.repository.MatchVerificationRepository;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class MatchVerificationService {

    private final MatchRepository matchRepository;
    private final MatchTeamRepository matchTeamRepository;
    private final MatchSquadMemberRepository squadMemberRepository;
    private final MatchVerificationRepository matchVerificationRepository;
    private final UserRepository userRepository;

    public VerificationContextResponse getVerificationContext(Long matchId, Long scorerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not ready for verification");
        }

        List<MatchTeam> matchTeams = matchTeamRepository.findByMatch(match);

        MatchTeam teamA = matchTeams.stream()
                .filter(mt -> "A".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team A not found"));

        MatchTeam teamB = matchTeams.stream()
                .filter(mt -> "B".equals(mt.getSide()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Team B not found"));

        VerificationContextResponse response = new VerificationContextResponse();
        response.setTeamA(buildTeamDTO(teamA, scorerUserId));
        response.setTeamB(buildTeamDTO(teamB, scorerUserId));

        return response;
    }

    private VerificationTeamDTO buildTeamDTO(MatchTeam matchTeam, Long scorerUserId) {

        VerificationTeamDTO dto = new VerificationTeamDTO();
        dto.setMatchTeamId(matchTeam.getId());
        dto.setTeamName(matchTeam.getTeam().getName());
        dto.setLogoUrl(matchTeam.getTeam().getLogoUrl());

        List<VerificationPlayerDTO> players = squadMemberRepository
                .findByMatchTeam(matchTeam)
                .stream()
                .map(member -> {

                    VerificationPlayerDTO playerDTO = new VerificationPlayerDTO();
                    playerDTO.setUserId(member.getUser().getId());
                    playerDTO.setName(member.getUser().getEmail()); // or better name if available
                    playerDTO.setGuest(false); // squad only contains registered users
                    playerDTO.setScorer(member.getUser().getId().equals(scorerUserId));

                    return playerDTO;
                })
                .toList();

        dto.setPlayers(players);

        return dto;
    }

    @Transactional
    public void sendVerificationRequest(
            Long scorerUserId,
            Long matchId,
            Long matchTeamId,
            Long selectedUserId
    ) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (match.getStatus() != MatchStatus.AWAITING_VERIFICATION) {
            throw new IllegalStateException("Match not in verification stage");
        }

        if (!match.getScorerUserId().equals(scorerUserId)) {
            throw new IllegalStateException("Only scorer can send verification");
        }

        if (scorerUserId.equals(selectedUserId)) {
            throw new IllegalStateException("Scorer cannot verify his own match");
        }

        MatchTeam matchTeam = matchTeamRepository.findById(matchTeamId)
                .orElseThrow(() -> new RuntimeException("Match team not found"));

        // Ensure player is in squad
        boolean inSquad = squadMemberRepository.findByMatchTeam(matchTeam)
                .stream()
                .anyMatch(member -> member.getUser().getId().equals(selectedUserId));

        if (!inSquad) {
            throw new IllegalStateException("Selected player not in squad");
        }

        // Prevent duplicate request per team
        if (matchVerificationRepository.findByMatchAndMatchTeam(match, matchTeam).isPresent()) {
            throw new IllegalStateException("Verification already sent for this team");
        }

        MatchVerification verification = new MatchVerification();
        verification.setMatch(match);
        verification.setMatchTeam(matchTeam);
        verification.setVerifier(
                userRepository.getReferenceById(selectedUserId)
        );
        verification.setStatus(MatchVerificationStatus.PENDING);

        matchVerificationRepository.save(verification);
    }

    @Transactional
    public void acceptVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.VERIFIED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        checkAndPromoteMatch(match);
    }

    @Transactional
    public void rejectVerification(Long matchId, Long playerUserId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        MatchVerification verification = matchVerificationRepository
                .findByMatch(match)
                .stream()
                .filter(v -> v.getVerifier().getId().equals(playerUserId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Verification request not found"));

        verification.setStatus(MatchVerificationStatus.REJECTED);
        verification.setRespondedAt(java.time.LocalDateTime.now());

        matchVerificationRepository.save(verification);

        match.setStatus(MatchStatus.DRAFT); // rollback stage
        matchRepository.save(match);
    }

    private void checkAndPromoteMatch(Match match) {

        boolean hasPending = matchVerificationRepository
                .existsByMatchAndStatus(match, MatchVerificationStatus.PENDING);

        if (!hasPending) {
            match.setStatus(MatchStatus.VERIFIED);
            matchRepository.save(match);
        }
    }



}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/AvailabilityStatus.java">
package in.crewplay.crewplay_backend.domain.teams.enums;
public enum AvailabilityStatus {
    AVAILABLE,
    UNAVAILABLE,
    INJURED,
    PENDING
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/JoinRequestStatus.java">
package in.crewplay.crewplay_backend.domain.teams.enums;

public enum JoinRequestStatus {
    PENDING,
    APPROVED,
    REJECTED,
    EXPIRED,
    CANCELLED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/JoinRequestType.java">
package in.crewplay.crewplay_backend.domain.teams.enums;
public enum JoinRequestType {
    PLAYER_REQUEST,
    MANAGER_INVITE,
    LINK_JOIN,
    QR_JOIN,
    TEAM_CODE_JOIN
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/enums/TeamStatus.java">
package in.crewplay.crewplay_backend.domain.teams.enums;

public enum TeamStatus {

    TEMPORARY,   // Created inside match flow
    ACTIVE,      // Permanent team
    ARCHIVED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/PlayerAvailability.java">
package in.crewplay.crewplay_backend.domain.teams;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.teams.enums.AvailabilityStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * Stores per-match squad state of a player.
 *
 * This entity represents match-scoped selection data:
 * - Availability (AVAILABLE / UNAVAILABLE / etc.)
 * - Playing XI inclusion
 * - Captain / Wicketkeeper role
 *
 * One record per (match + team + player).
 * Enforced via unique constraint.
 */
@Entity
@Table(
        name = "player_availability",

        // Prevent duplicate availability records for same match/team/player
        uniqueConstraints = @UniqueConstraint(
                columnNames = {"match_id", "team_id", "player_user_id"}
        ),

        // Indexes for squad queries and performance
        indexes = {
                @Index(name = "idx_pa_match_team", columnList = "match_id, team_id"),
                @Index(name = "idx_pa_player", columnList = "player_user_id")
        }
)
@Getter
@Setter
public class PlayerAvailability {

    /**
     * Primary key (auto-generated).
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Match to which this availability belongs.
     * Mandatory relationship.
     */
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "match_id", nullable = false)
    private Match match;

    /**
     * Team context for the match.
     * Mandatory relationship.
     */
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    /**
     * Player whose availability is being tracked.
     * Mandatory relationship.
     */
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "player_user_id", nullable = false)
    private User player;

    /**
     * Player's availability status for this match.
     * Default: PENDING until player confirms.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AvailabilityStatus status = AvailabilityStatus.PENDING;

    /**
     * True if player is selected in final Playing XI.
     * Controlled by manager during squad confirmation.
     */
    @Column(name = "is_in_playing_xi", nullable = false)
    private Boolean isInPlayingXi = false;

    /**
     * True if player is assigned as Captain for this match.
     * Exactly one captain should exist per team per match
     * (validated at service layer).
     */
    @Column(name = "is_captain", nullable = false)
    private Boolean isCaptain = false;

    /**
     * True if player is assigned as Wicketkeeper for this match.
     * Exactly one wicketkeeper should exist per team per match
     * (validated at service layer).
     */
    @Column(name = "is_wicket_keeper", nullable = false)
    private Boolean isWicketKeeper = false;

    /**
     * Timestamp when player confirmed availability.
     * Null until player responds.
     */
    @Column(name = "confirmed_at")
    private LocalDateTime confirmedAt;

    /**
     * Creation timestamp of availability record.
     */
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/repository/JoinRequestStatus.java">
package in.crewplay.crewplay_backend.domain.teams.repository;
public enum JoinRequestStatus {
    PENDING,
    APPROVED,
    REJECTED,
    EXPIRED,
    CANCELLED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/repository/TeamPlayerRepository.java">
package in.crewplay.crewplay_backend.domain.teams.repository;

import in.crewplay.crewplay_backend.domain.teams.TeamPlayer;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface TeamPlayerRepository extends JpaRepository<TeamPlayer, Long> {

    boolean existsByTeamIdAndUserId(Long teamId, Long userId);

    List<TeamPlayer> findByTeamIdAndIsActiveTrue(Long teamId);


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/Team.java">
package in.crewplay.crewplay_backend.domain.teams;

import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "teams",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "team_code"),
                @UniqueConstraint(columnNames = {"name", "city"})
        }
)
@Getter
@Setter
public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- BASIC INFO ----------

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String city;

    @Column(name = "logo_url")
    private String logoUrl;

    // ---------- TEAM CODE (JOINING / QR / LINK) ----------

    @Column(name = "team_code", nullable = false, unique = true)
    private String teamCode;

    // ---------- CAPTAIN & OWNERSHIP ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "captain_user_id", nullable = false)
    private User captain;


    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TeamStatus status = TeamStatus.TEMPORARY;

    // ---------- TRUST / VERIFICATION ----------

    @Column(name = "is_verified", nullable = false)
    private Boolean isVerified = false; // Phase-0 always false

    @Column(name = "verification_method")
    private String verificationMethod; // EMAIL (Phase-0)

    @Column(name = "verified_at")
    private LocalDateTime verifiedAt;

    // ---------- SYSTEM ----------

    @Column(name = "created_by_scorer_id", nullable = false)
    private Long createdByScorerId;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // These are the attributes for the team manager:
    @Column(name = "manager_user_id")
    private Long managerUserId;   //  Set when manager creates/claims team

    @Column(name = "home_ground")
    private String homeGround;    //  Shown in match cards

    @Column(name = "active_league")
    private String activeLeague;  //  e.g. "Premier League 2024"

    @Column(name = "wins", nullable = false)
    private Integer wins = 0;

    @Column(name = "losses", nullable = false)
    private Integer losses = 0;

    @Column(name = "draws", nullable = false)
    private Integer draws = 0;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamJoinRequest.java">
package in.crewplay.crewplay_backend.domain.teams;
// Handles BOTH player-initiated join requests AND manager invitations

import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestType;
import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestStatus;


import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.team.enums.JoinRequestStatusForOverAllTeam;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "team_join_requests",
        uniqueConstraints = @UniqueConstraint(columnNames = {"team_id", "player_user_id", "status"}))
@Getter
@Setter
public class TeamJoinRequest {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "team_id") private Team team;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "player_user_id") private User player;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "initiated_by_user_id") private User initiatedBy;

    @Enumerated(EnumType.STRING) private JoinRequestType type;
    @Enumerated(EnumType.STRING) private JoinRequestStatus status = JoinRequestStatus.PENDING;
    @Column(columnDefinition = "TEXT") private String message;
    private LocalDateTime createdAt = LocalDateTime.now();
    private LocalDateTime respondedAt;
    private LocalDateTime expiresAt; // 7-day expiry for invites

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamMember.java">
package in.crewplay.crewplay_backend.domain.teams;

import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "team_members",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"team_id", "user_id"})
        }
)
@Getter
@Setter
public class TeamMember {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ---------- RELATIONS ----------

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;

    /**
     * Can be NULL for guest players
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    // ---------- PLAYER INFO ----------

    @Column(name = "display_name", nullable = false)
    private String displayName;

    @Column(name = "mobile_number", nullable = false)
    private String mobileNumber;

    @Column(name = "is_guest", nullable = false)
    private Boolean isGuest = false;

    // ---------- HOW THEY WERE ADDED ----------

    @Enumerated(EnumType.STRING)
    @Column(name = "add_method", nullable = false)
    private PlayerAddMethod addMethod;

    @Column(name = "added_by_scorer_id", nullable = false)
    private Long addedByScorerId;

    // ---------- TRUST / REPORTING (PHASE-1 READY) ----------

    @Column(name = "reported", nullable = false)
    private Boolean reported = false;

    // ---------- SYSTEM ----------

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/teams/TeamPlayer.java">
package in.crewplay.crewplay_backend.domain.teams;

import in.crewplay.crewplay_backend.domain.user.User;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "team_players",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = {"team_id", "user_id"})
        })
@Getter
@Setter
public class TeamPlayer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "team_id")
    private Team team;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "joined_at")
    private LocalDateTime joinedAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/ExperienceLevel.java">
package in.crewplay.crewplay_backend.domain.user;

public enum ExperienceLevel {
    BEGINNER,
    INTERMEDIATE,
    ADVANCED,
    PROFESSIONAL

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/Gender.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Gender {
    MALE,
    FEMALE,
    OTHER
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/PlayerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "player_profiles")
@Getter
@Setter
public class PlayerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Enumerated(EnumType.STRING)
    private Gender gender;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // CRICKET INFO
    @Enumerated(EnumType.STRING)
    @Column(name = "playing_role")
    private PlayingRole playingRole;

    private String battingStyle;
    private String bowlingStyle;

    @Enumerated(EnumType.STRING)
    @Column(name = "experience_level")
    private ExperienceLevel experienceLevel;

    // LOCATION
    private String city;

    // MEDIA
    @Column(name = "profile_image_url")
    private String profileImageUrl;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SYSTEM
    @Column(name = "is_profile_complete")
    private Boolean isProfileComplete = false;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/PlayingRole.java">
package in.crewplay.crewplay_backend.domain.user;

public enum PlayingRole {
    WICKET_KEEPER,
    OPENING_BATSMAN,
    MIDDLE_ORDER_BATSMAN,
    LOWER_ORDER_BATSMAN,
    ALL_ROUNDER
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository; // Ensure this matches your folder

import in.crewplay.crewplay_backend.domain.user.User;
import io.lettuce.core.dynamic.annotation.Param;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    // This allows .findByEmail() to work in AuthController
    Optional<User> findByEmail(String email);
    Optional<User> findByMobileNumber(String mobileNumber);

    /**
     * Search active users by email (case-insensitive),
     * excluding current user and already-associated users.
     *
     * Used for Recruit / Discover players screen.
     */
    @Query("""
    SELECT u FROM User u
    WHERE u.isActive = true
      AND u.id != :excludeId
      AND (:excludeIds IS NULL OR u.id NOT IN :excludeIds)
      AND LOWER(u.email) LIKE LOWER(CONCAT('%', :query, '%'))
""")
    List<User> searchByEmail(
            @Param("query") String query,
            @Param("excludeId") Long excludeId,
            @Param("excludeIds") List<Long> excludeIds
    );


    /**
     * Fetch all active users excluding specific IDs.
     * Used when no search query is provided.
     */
    @Query("""
    SELECT u FROM User u
    WHERE u.isActive = true
      AND u.id != :excludeId
      AND (:excludeIds IS NULL OR u.id NOT IN :excludeIds)
""")
    List<User> findAllExcluding(
            @Param("excludeId") Long excludeId,
            @Param("excludeIds") List<Long> excludeIds
    );



}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/repository/UserRoleRepository.java">
package in.crewplay.crewplay_backend.domain.user.repository;

import in.crewplay.crewplay_backend.domain.user.UserRole;
import in.crewplay.crewplay_backend.domain.user.Role;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserRoleRepository extends JpaRepository<UserRole, Long> {

    List<UserRole> findByUserId(Long userId);

    Optional<UserRole> findByUserIdAndRole(Long userId, Role role);

    Optional<UserRole> findByUserIdAndIsActiveTrue(Long userId);


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/Role.java">
package in.crewplay.crewplay_backend.domain.user;

public enum Role {
    PLAYER,
    SCORER,
    TEAM_MANAGER
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/ScorerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "scorer_profiles")
@Getter
@Setter
public class ScorerProfile {

    @Id
    private Long id;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL (COUNTS ONLY)
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // SCORER TRUST SIGNAL
    @Column(name = "unverified_matches_count")
    private Long unverifiedMatchesCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    private Integer matchesScored = 0;
    private Double accuracy = 100.0;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/TeamManagerProfile.java">
package in.crewplay.crewplay_backend.domain.user;

import in.crewplay.crewplay_backend.domain.teams.Team;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;


import java.time.LocalDateTime;

@Entity
@Table(name = "team_manager_profiles")
@Getter
@Setter
public class TeamManagerProfile {

    @Id
    private Long id; // SAME AS users.id

    @MapsId
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "id")
    private User user;

    // BASIC INFO
    private String name;

    @Column(name = "profile_image_url")
    private String profileImageUrl;

    private String city;

    private String email;

    @Column(name = "mobile_number")
    private String mobileNumber;

    // SOCIAL
    @Column(name = "followers_count")
    private Long followersCount = 0L;

    @Column(name = "following_count")
    private Long followingCount = 0L;

    // TEAM MANAGEMENT META
    @Column(name = "teams_handled_count")
    private Long teamsHandledCount = 0L;

    // META
    @Column(name = "member_since")
    private LocalDateTime memberSince;

    // SYSTEM
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ---------- ACTIVE TEAM ----------

    @Column(name = "active_team_id")
    private Long activeTeamId;


// ---------- CAREER STATS ----------

    @Column(name = "total_seasons", nullable = false)
    private Integer totalSeasons = 0;

    @Column(name = "total_matches_managed", nullable = false)
    private Integer totalMatchesManaged = 0;

    @Column(name = "total_wins", nullable = false)
    private Integer totalWins = 0;

    @Column(name = "total_losses", nullable = false)
    private Integer totalLosses = 0;


// ---------- PERFORMANCE METRICS ----------

    @Column(name = "manager_rank")
    private Integer managerRank;

    @Column(name = "form_rating", nullable = false)
    private Double formRating = 0.0;


// ---------- PERMISSIONS ----------

    @Column(name = "can_schedule_matches", nullable = false)
    private Boolean canScheduleMatches = true;

    @Column(name = "can_recruit_players", nullable = false)
    private Boolean canRecruitPlayers = true;

    @Column(name = "can_manage_finances", nullable = false)
    private Boolean canManageFinances = false;

    @Column(name = "is_verified_manager", nullable = false)
    private Boolean isVerifiedManager = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "active_team_id")
    private Team activeTeam;


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/User.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Getter
@Setter
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "mobile_number", nullable = false, unique = true)
    private String mobileNumber;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "is_active")
    private Boolean isActive = true;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/UserFollow.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_follows",
        uniqueConstraints = @UniqueConstraint(
                columnNames = {"follower_user_id", "following_user_id"}
        )
)
@Getter
@Setter
public class UserFollow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "follower_user_id", nullable = false)
    private User follower;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "following_user_id", nullable = false)
    private User following;

    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/domain/user/UserRole.java">
package in.crewplay.crewplay_backend.domain.user;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "user_roles",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "role"})
)
@Getter
@Setter
public class UserRole {

    @Id // Corrected Import: jakarta.persistence.Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @Column(nullable = false)
    private Boolean isActive = false; // Added this for your logic to work!

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Controller/MatchSetupController.java">
package in.crewplay.crewplay_backend.match_setup.Controller;

public class MatchSetupController {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/CreateQuickMatchRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class CreateQuickMatchRequest {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectSquadRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectSquadRequest {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/request/SelectTeamRequest.java">
package in.crewplay.crewplay_backend.match_setup.dto.request;

public class SelectTeamRequest {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/dto/response/MatchSetupResponse.java">
package in.crewplay.crewplay_backend.match_setup.dto.response;

public class MatchSetupResponse {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchRepository {


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Repository/MatchSquadRepository.java">
package in.crewplay.crewplay_backend.match_setup.Repository;

public class MatchSquadRepository {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/match_setup/Service/MatchSetupService.java">
package in.crewplay.crewplay_backend.match_setup.Service;

public class MatchSetupService {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Controller/ScorerController.java">
package in.crewplay.crewplay_backend.Scorer.Controller;

import in.crewplay.crewplay_backend.Scorer.Service.ScorerService;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/scorer")
@RequiredArgsConstructor
public class ScorerController {

    private final ScorerService scorerService;

    @GetMapping("/me")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<ScorerProfile> getMyScorerProfile(
            @RequestAttribute("userId") Long userId
    ) {
        ScorerProfile profile = scorerService.getOrCreateScorerProfile(userId);
        return ResponseEntity.ok(profile);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Repository/ScorerProfileRepository.java">
package in.crewplay.crewplay_backend.Scorer.Repository;

import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import org.springframework.data.jpa.repository.JpaRepository;

public interface ScorerProfileRepository extends JpaRepository<ScorerProfile, Long> {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/Scorer/Service/ScorerService.java">
package in.crewplay.crewplay_backend.Scorer.Service;

import in.crewplay.crewplay_backend.Scorer.Repository.ScorerProfileRepository;
import in.crewplay.crewplay_backend.domain.user.ScorerProfile;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class ScorerService {

    private final ScorerProfileRepository scorerProfileRepository;
    private final UserRepository userRepository;

    public ScorerProfile getOrCreateScorerProfile(Long userId) {

        return scorerProfileRepository.findById(userId)
                .orElseGet(() -> {
                    User user = userRepository.findById(userId)
                            .orElseThrow(() -> new RuntimeException("User not found"));

                    ScorerProfile scorerProfile = new ScorerProfile();
                    scorerProfile.setId(userId);
                    scorerProfile.setUser(user);

                    // Auto-copy from User
                    scorerProfile.setEmail(user.getEmail());
                    scorerProfile.setMobileNumber(user.getMobileNumber());
                    scorerProfile.setName(extractNameFromEmail(user.getEmail()));

                    scorerProfile.setMemberSince(LocalDateTime.now());
                    scorerProfile.setCreatedAt(LocalDateTime.now());

                    return scorerProfileRepository.save(scorerProfile);
                });
    }

    private String extractNameFromEmail(String email) {
        return email.split("@")[0];
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerAnalyticsController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.team_manager.Service.ManagerAnalyticsService;
import in.crewplay.crewplay_backend.team_manager.dto.response.FullTeamStatsResponse;
import in.crewplay.crewplay_backend.team_manager.dto.response.MatchAnalyticsResponse;
import in.crewplay.crewplay_backend.team_manager.dto.response.PlayerProfileStatsResponse;
import in.crewplay.crewplay_backend.team_manager.dto.response.TeamAnalyticsResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/team-manager/teams/{teamId}/analytics")
@RequiredArgsConstructor
public class ManagerAnalyticsController {

    private final ManagerAnalyticsService analyticsService;

    /**
     * Team analytics (last 5 matches).
     */
    @GetMapping
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<TeamAnalyticsResponse> getTeamAnalytics(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        return ResponseEntity.ok(
                analyticsService.getTeamAnalytics(userId, teamId)
        );
    }

    /**
     * Match analytics.
     */
    @GetMapping("/match/{matchId}")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<MatchAnalyticsResponse> getMatchAnalytics(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long matchId) {

        return ResponseEntity.ok(
                analyticsService.getMatchAnalytics(userId, teamId, matchId)
        );
    }

    /**
     * Full team stats.
     */
    @GetMapping("/full-stats")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<FullTeamStatsResponse> getFullTeamStats(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        return ResponseEntity.ok(
                analyticsService.getFullTeamStats(userId, teamId)
        );
    }

    /**
     * Individual player stats.
     */
    @GetMapping("/player/{playerId}")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<PlayerProfileStatsResponse> getPlayerStats(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long playerId) {

        return ResponseEntity.ok(
                analyticsService.getPlayerStats(userId, teamId, playerId)
        );
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerApprovalController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.team_manager.Service.ManagerApprovalService;
import in.crewplay.crewplay_backend.team_manager.dto.response.ApprovalsOverviewResponse;
import in.crewplay.crewplay_backend.team_manager.dto.response.PendingApprovalResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Handles approval actions for join requests.
 */
@RestController
@RequestMapping("/team-manager/teams/{teamId}/approvals")
@RequiredArgsConstructor
public class ManagerApprovalController {

    private final ManagerApprovalService approvalService;

    @GetMapping
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<ApprovalsOverviewResponse> getApprovals(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        return ResponseEntity.ok(
                approvalService.getApprovals(userId, teamId)
        );
    }

    @PostMapping("/{requestId}/approve")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> approve(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long requestId) {

        approvalService.approveRequest(userId, teamId, requestId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{requestId}/reject")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> reject(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long requestId) {

        approvalService.rejectRequest(userId, teamId, requestId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/history")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<List<PendingApprovalResponse>> getHistory(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        return ResponseEntity.ok(
                approvalService.getHistory(userId, teamId)
        );
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerDashboardController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

public class ManagerDashboardController {


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerRecruitController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

public class ManagerRecruitController {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerRosterController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.domain.teams.TeamMember;
import in.crewplay.crewplay_backend.team_manager.dto.request.AddGuestRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.InvitePlayerRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.RosterPlayerResponse;
import in.crewplay.crewplay_backend.team_manager.Service.ManagerRosterService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Handles team roster management.
 */
@RestController
@RequestMapping("/team-manager/teams/{teamId}/roster")
@RequiredArgsConstructor
public class ManagerRosterController {

    private final ManagerRosterService rosterService;

    @GetMapping
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<List<RosterPlayerResponse>> getRoster(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        return ResponseEntity.ok(
                rosterService.getRoster(userId, teamId)
        );
    }

    @PostMapping("/invite")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<String> invitePlayer(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @RequestBody InvitePlayerRequest request) {

        return ResponseEntity.ok(
                rosterService.invitePlayerByMobile(userId, teamId, request)
        );
    }

    @PostMapping("/guest")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<TeamMember> addGuest(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @RequestBody AddGuestRequest request) {

        return ResponseEntity.ok(
                rosterService.addGuestPlayer(userId, teamId, request)
        );
    }

    @DeleteMapping("/{memberId}")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> removePlayer(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long memberId) {

        rosterService.removePlayer(userId, teamId, memberId);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerSquadController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.team_manager.dto.request.ConfirmPlayingXiRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateAvailabilityRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.SquadManagementResponse;
import in.crewplay.crewplay_backend.team_manager.Service.ManagerSquadService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

/**
 * Handles squad and Playing XI management.
 */
@RestController
@RequestMapping("/team-manager/teams/{teamId}/squad")
@RequiredArgsConstructor
public class ManagerSquadController {

    private final ManagerSquadService squadService;

    /**
     * Get full squad view for match.
     */
    @GetMapping("/{matchId}")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<SquadManagementResponse> getSquadView(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @PathVariable Long matchId) {

        return ResponseEntity.ok(
                squadService.getSquadView(userId, teamId, matchId)
        );
    }

    /**
     * Player updates their availability.
     */
    @PostMapping("/availability")
    @PreAuthorize("hasAnyRole('PLAYER','TEAM_MANAGER')")
    public ResponseEntity<Void> updateAvailability(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @RequestBody UpdateAvailabilityRequest request) {

        squadService.updatePlayerAvailability(userId, teamId, request);
        return ResponseEntity.ok().build();
    }

    /**
     * Manager confirms Playing XI.
     */
    @PostMapping("/confirm-xi")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> confirmPlayingXi(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @RequestBody ConfirmPlayingXiRequest request) {

        squadService.confirmPlayingXi(userId, teamId, request);
        return ResponseEntity.ok().build();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/ManagerTeamController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.team_manager.dto.request.CreateTeamManagerRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateTeamRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.TeamSummaryResponse;
import in.crewplay.crewplay_backend.team_manager.Service.ManagerTeamService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Handles team creation and management.
 */
@RestController
@RequestMapping("/team-manager/teams")
@RequiredArgsConstructor
public class ManagerTeamController {

    private final ManagerTeamService teamService;

    /**
     * Create a new team (Manager Mode).
     */
    @PostMapping
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Team> createTeam(
            @RequestAttribute("userId") Long userId,
            @RequestBody CreateTeamManagerRequest request) {

        return ResponseEntity.ok(
                teamService.createTeam(userId, request)
        );
    }

    /**
     * Get all teams managed by user.
     */
    @GetMapping
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<List<TeamSummaryResponse>> getMyTeams(
            @RequestAttribute("userId") Long userId) {

        return ResponseEntity.ok(
                teamService.getMyTeams(userId)
        );
    }

    /**
     * Switch active team.
     */
    @PostMapping("/{teamId}/switch")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> switchTeam(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId) {

        teamService.switchActiveTeam(userId, teamId);
        return ResponseEntity.ok().build();
    }

    /**
     * Update team details.
     */
    @PutMapping("/{teamId}")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Team> updateTeam(
            @RequestAttribute("userId") Long userId,
            @PathVariable Long teamId,
            @RequestBody UpdateTeamRequest request) {

        return ResponseEntity.ok(
                teamService.updateTeam(userId, teamId, request)
        );
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Controller/TeamManagerProfileController.java">
package in.crewplay.crewplay_backend.team_manager.Controller;

import in.crewplay.crewplay_backend.domain.user.TeamManagerProfile;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateManagerProfileRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.TeamManagerProfileResponse;
import in.crewplay.crewplay_backend.team_manager.Service.TeamManagerProfileService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

/**
 * Handles Team Manager profile operations.
 */
@RestController
@RequestMapping("/team-manager")
@RequiredArgsConstructor
public class TeamManagerProfileController {

    private final TeamManagerProfileService profileService;

    /**
     * GET Profile
     */
    @GetMapping("/me")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<TeamManagerProfileResponse> getMyProfile(
            @RequestAttribute("userId") Long userId) {

        return ResponseEntity.ok(
                profileService.buildProfileResponse(userId)
        );
    }

    /**
     * UPDATE Profile
     */
    @PutMapping("/me")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<TeamManagerProfile> updateProfile(
            @RequestAttribute("userId") Long userId,
            @RequestBody UpdateManagerProfileRequest request) {

        return ResponseEntity.ok(
                profileService.updateProfile(userId, request)
        );
    }

    /**
     * DELETE Account (Soft Delete)
     */
    @DeleteMapping("/me")
    @PreAuthorize("hasRole('TEAM_MANAGER')")
    public ResponseEntity<Void> deleteAccount(
            @RequestAttribute("userId") Long userId) {

        profileService.deleteAccount(userId);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/AddGuestRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

/**
 * Used when manager adds a manual guest player.
 */
@Getter
@Setter
public class AddGuestRequest {

    private String displayName;
    private String mobileNumber;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/ConfirmPlayingXiRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

/**
 * Used when manager confirms Playing XI.
 */
@Getter
@Setter
public class ConfirmPlayingXiRequest {

    private Long matchId;

    private List<Long> playerUserIds;

    private Long captainUserId;
    private Long wicketKeeperUserId;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/CreateTeamManagerRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

/**
 * Used when manager creates a new team.
 */
@Getter
@Setter
public class CreateTeamManagerRequest {

    private String teamName;
    private String city;
    private String logoUrl;
    private String homeGround;

    private boolean makeManagerCaptain;   // true  manager becomes captain
    private String captainMobileNumber;   // required if not self-captain
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/InvitePlayerRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

/**
 * Used when manager invites a registered player by mobile.
 */
@Getter
@Setter
public class InvitePlayerRequest {

    private String mobileNumber;
    private String message;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateAvailabilityRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import in.crewplay.crewplay_backend.domain.teams.enums.AvailabilityStatus;
import lombok.Getter;
import lombok.Setter;

/**
 * Used when a player confirms availability for a match.
 */
@Getter
@Setter
public class UpdateAvailabilityRequest {

    private Long matchId;
    private AvailabilityStatus status;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateManagerProfileRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

/**
 * Used when manager edits profile.
 * Only editable fields are included.
 */
@Getter
@Setter
public class UpdateManagerProfileRequest {

    private String name;
    private String profileImageUrl;
    private String city;
    private String mobileNumber;

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/request/UpdateTeamRequest.java">
package in.crewplay.crewplay_backend.team_manager.dto.request;

import lombok.Getter;
import lombok.Setter;

/**
 * Used to update team details.
 */
@Getter
@Setter
public class UpdateTeamRequest {

    private String teamName;
    private String logoUrl;
    private String homeGround;
    private String activeLeague;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/ApprovalsOverviewResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

import java.util.List;


/**
 * Contains approval stats + list of pending requests.
 */
@Getter
@Builder
public class ApprovalsOverviewResponse {

    private Integer totalPending;
    private Integer newToday;
    private Integer expiringSoon;

    private List<PendingApprovalResponse> requests;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/FullTeamStatsResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

import java.util.List;

/**
 * Used for full team statistics table.
 */
@Getter
@Builder
public class FullTeamStatsResponse {

    private List<PlayerStatRow> players;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/MatchAnalyticsResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Used for individual match analytics.
 */
@Getter
@Builder
public class MatchAnalyticsResponse {

    private Long matchId;

    private Integer teamScore;
    private Integer opponentScore;

    private String result;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PendingApprovalResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Represents one join request in approvals screen.
 */
@Getter
@Builder
public class PendingApprovalResponse {

    private Long requestId;
    private Long playerId;
    private String playerName;

    private String requestType;

    private String createdAt;
    private String expiresAt;

    private Boolean isExpiringSoon;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PlayerProfileStatsResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Used for detailed player profile analytics.
 */
@Getter
@Builder
public class PlayerProfileStatsResponse {

    private Long userId;
    private Integer totalRuns;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/PlayerStatRow.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Represents one player row in team stats.
 */
@Getter
@Builder
public class PlayerStatRow {

    private Long userId;
    private Integer runs;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/RosterPlayerResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Represents each player in roster screen.
 */
@Getter
@Builder
public class RosterPlayerResponse {

    private Long memberId;
    private Long userId;

    private String displayName;
    private String mobileNumber;

    private String addMethod;
    private Boolean isGuest;

    private String verificationStatus;  // Guest / Verified / Pending
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/SquadManagementResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

import java.util.List;

/**
 * Full squad overview for a match.
 */
@Getter
@Builder
public class SquadManagementResponse {

    private Long matchId;
    private String matchTitle;

    private Integer playingXiSelected;
    private Integer playingXiTotal;
    private Integer totalSquad;

    private Integer available;
    private Integer unavailable;
    private Integer pending;

    private SquadPlayerCard captain;
    private SquadPlayerCard wicketKeeper;

    private List<SquadPlayerCard> players;

    private Boolean isXiConfirmed;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/SquadPlayerCard.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Represents one player in squad view.
 */
@Getter
@Builder
public class SquadPlayerCard {

    private Long userId;
    private String displayName;

    private String availabilityStatus;

    private Boolean isInPlayingXi;
    private Boolean isCaptain;
    private Boolean isWicketKeeper;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamAnalyticsResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

import java.util.List;

/**
 * Used for Team analytics screen.
 */
@Getter
@Builder
public class TeamAnalyticsResponse {

    private Double winRate;
    private Integer avgScore;
    private Double netRunRate;

    private List<Integer> formTrend;

    private List<TopContributorResponse> topBatters;
    private List<TopContributorResponse> topBowlers;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamManagerProfileResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Sent to frontend when manager opens Profile screen.
 */
@Getter
@Builder
public class TeamManagerProfileResponse {

    private Long userId;
    private String name;
    private String email;
    private String mobileNumber;
    private String city;
    private String profileImageUrl;

    private Long followersCount;
    private Long followingCount;

    private Integer totalSeasons;
    private Integer totalMatchesManaged;
    private Integer totalWins;
    private Integer totalLosses;
    private Double winRate;

    private Double formRating;
    private Integer managerRank;

    private Long activeTeamId;
    private Boolean canScheduleMatches;
    private Boolean canRecruitPlayers;
    private Boolean canManageFinances;
    private Boolean isVerifiedManager;

    private String memberSince;
    private Long teamsHandledCount;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TeamSummaryResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Shown in "My Teams" screen.
 */
@Getter
@Builder
public class TeamSummaryResponse {

    private Long teamId;
    private String teamName;
    private String logoUrl;
    private String homeGround;
    private String activeLeague;

    private String status;

    private Integer wins;
    private Integer losses;
    private Integer draws;

    private Boolean isCurrentActive;
    private String teamCode;

    private Integer totalPlayers;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/dto/response/TopContributorResponse.java">
package in.crewplay.crewplay_backend.team_manager.dto.response;

import lombok.Builder;
import lombok.Getter;

/**
 * Used for top batters/bowlers lists.
 */
@Getter
@Builder
public class TopContributorResponse {

    private Long userId;
    private Integer runs;
    private Integer balls;
    private Integer wickets;
    private Double strikeRate;
    private Double economy;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Repository/TeamManagerProfileRepository.java">
package in.crewplay.crewplay_backend.team_manager.Repository;

import in.crewplay.crewplay_backend.domain.user.TeamManagerProfile;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface TeamManagerProfileRepository
        extends JpaRepository<TeamManagerProfile, Long> {

    Optional<TeamManagerProfile> findByUser_Id(Long userId);


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerAnalyticsService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.match.scoring.entity.BallEvent;
import in.crewplay.crewplay_backend.domain.match.scoring.repository.BallEventRepository;
import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.team_manager.dto.response.*;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ManagerAnalyticsService {

    private final MatchRepository matchRepository;
    private final BallEventRepository ballEventRepository;
    private final TeamRepository teamRepository;

    /**
     * Team analytics for last 5 completed matches.
     */
    public TeamAnalyticsResponse getTeamAnalytics(Long managerUserId, Long teamId) {

        validateManagerOwnership(managerUserId, teamId);

        List<Match> matches =
                matchRepository.findRecentCompletedByTeam(teamId, 5);

        if (matches.isEmpty()) {
            return TeamAnalyticsResponse.builder()
                    .winRate(0.0)
                    .avgScore(0)
                    .netRunRate(0.0)
                    .formTrend(List.of())
                    .topBatters(List.of())
                    .topBowlers(List.of())
                    .build();
        }

        List<Long> matchIds = matches.stream()
                .map(Match::getId)
                .toList();

        List<BallEvent> allEvents =
                ballEventRepository.findByMatch_IdIn(matchIds);

        long wins = matches.stream()
                .filter(m -> didTeamWin(m, teamId))
                .count();

        double winRate =
                (double) wins / matches.size() * 100;

        Map<Long, List<BallEvent>> matchEventMap =
                allEvents.stream()
                        .collect(Collectors.groupingBy(e -> e.getMatch().getId()));

        List<Integer> scores = new ArrayList<>();

        for (Match match : matches) {

            List<BallEvent> events =
                    matchEventMap.getOrDefault(match.getId(), List.of());

            int teamScore = calculateTeamScore(events, teamId);
            scores.add(teamScore);
        }

        int avgScore = (int) scores.stream()
                .mapToInt(Integer::intValue)
                .average()
                .orElse(0);

        return TeamAnalyticsResponse.builder()
                .winRate(round(winRate))
                .avgScore(avgScore)
                .formTrend(scores)
                .build();
    }

    /**
     * Match analytics.
     */
    public MatchAnalyticsResponse getMatchAnalytics(Long managerUserId,
                                                    Long teamId,
                                                    Long matchId) {

        validateManagerOwnership(managerUserId, teamId);

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.containsTeam(teamId))
            throw new IllegalStateException("Match does not belong to team");

        if (!match.isCompleted())
            throw new IllegalStateException("Match not completed");

        List<BallEvent> events =
                ballEventRepository.findByMatch(match);

        int teamScore = calculateTeamScore(events, teamId);
        int opponentScore = calculateOpponentScore(events, teamId);

        return MatchAnalyticsResponse.builder()
                .matchId(matchId)
                .teamScore(teamScore)
                .opponentScore(opponentScore)
                .result(teamScore > opponentScore ? "WIN" : "LOSS")
                .build();
    }

    /**
     * Full team stats.
     */
    public FullTeamStatsResponse getFullTeamStats(Long managerUserId,
                                                  Long teamId) {

        validateManagerOwnership(managerUserId, teamId);

        List<Match> matches =
                matchRepository.findCompletedByTeam(teamId);

        List<Long> matchIds =
                matches.stream().map(Match::getId).toList();

        List<BallEvent> events =
                ballEventRepository.findByMatch_IdIn(matchIds);

        Map<Long, Integer> runsByPlayer = new HashMap<>();

        for (BallEvent e : events) {
            if (e.getInnings()
                    .getBattingTeam()
                    .getId()
                    .equals(teamId))
            {

                runsByPlayer.merge(
                        e.getBatsman().getId(),
                        e.getRunsOffBat(),
                        Integer::sum
                );
            }
        }

        List<PlayerStatRow> rows =
                runsByPlayer.entrySet().stream()
                        .map(entry ->
                                PlayerStatRow.builder()
                                        .userId(entry.getKey())
                                        .runs(entry.getValue())
                                        .build())
                        .sorted((a, b) -> b.getRuns() - a.getRuns())
                        .toList();

        return FullTeamStatsResponse.builder()
                .players(rows)
                .build();
    }

    /**
     * Individual player stats.
     */
    public PlayerProfileStatsResponse getPlayerStats(Long managerUserId,
                                                     Long teamId,
                                                     Long playerId) {

        validateManagerOwnership(managerUserId, teamId);

        List<Match> matches =
                matchRepository.findCompletedByTeam(teamId);

        List<Long> matchIds =
                matches.stream().map(Match::getId).toList();

        List<BallEvent> events =
                ballEventRepository.findByMatch_IdIn(matchIds);

        int totalRuns = events.stream()
                .filter(e -> e.getBatsman() != null
                        && e.getBatsman().getId().equals(playerId)
                        && e.getInnings()
                        .getBattingTeam()
                        .getId()
                        .equals(teamId))
                .mapToInt(BallEvent::getRunsOffBat)
                .sum();

        return PlayerProfileStatsResponse.builder()
                .userId(playerId)
                .totalRuns(totalRuns)
                .build();
    }

    //  Helper Methods 

    private void validateManagerOwnership(Long managerUserId,
                                          Long teamId) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!team.getManagerUserId().equals(managerUserId))
            throw new IllegalStateException("Access denied");
    }

    private boolean didTeamWin(Match match, Long teamId) {
        return match.getWinnerTeam() != null
                && match.getWinnerTeam().getId().equals(teamId);

    }

    private int calculateTeamScore(List<BallEvent> events,
                                   Long teamId) {

        return events.stream()
                .filter(e -> e.getInnings()
                        .getBattingTeam()
                        .getId()
                        .equals(teamId))
                .mapToInt(e -> e.getRunsOffBat() + e.getExtraRuns())
                .sum();
    }


    private int calculateOpponentScore(List<BallEvent> events,
                                       Long teamId) {

        return events.stream()
                .filter(e -> !e.getInnings()
                        .getBattingTeam()
                        .getId()
                        .equals(teamId))
                .mapToInt(e -> e.getRunsOffBat() + e.getExtraRuns())
                .sum();
    }


    private double round(double value) {
        return Math.round(value * 10.0) / 10.0;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerApprovalService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.domain.teams.*;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestStatus;
import in.crewplay.crewplay_backend.team.enums.JoinRequestStatusForOverAllTeam;
import in.crewplay.crewplay_backend.team.repository.TeamJoinRequestRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.team_manager.dto.response.ApprovalsOverviewResponse;
import in.crewplay.crewplay_backend.team_manager.dto.response.PendingApprovalResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Handles approval and rejection of team join requests.
 */
@Service
@RequiredArgsConstructor
public class ManagerApprovalService {

    private static final DateTimeFormatter DATE_FORMAT =
            DateTimeFormatter.ofPattern("dd MMM yyyy");

    private final TeamRepository teamRepository;
    private final TeamJoinRequestRepository joinRequestRepository;
    private final TeamMemberRepository teamMemberRepository;

    /**
     * Returns pending requests with header statistics.
     */
    public ApprovalsOverviewResponse getApprovals(Long managerUserId, Long teamId) {

        Team team = getTeamAndVerify(managerUserId, teamId);
        LocalDateTime now = LocalDateTime.now();

        List<PendingApprovalResponse> requests =
                joinRequestRepository
                        .findByTeamAndStatus(team, JoinRequestStatusForOverAllTeam.PENDING)
                        .stream()
                        .map(r -> buildCard(r, now))
                        .collect(Collectors.toList());

        return ApprovalsOverviewResponse.builder()
                .totalPending(
                        joinRequestRepository.countByTeamAndStatus(team, JoinRequestStatusForOverAllTeam.PENDING)
                )
                .newToday(
                        joinRequestRepository.countNewSince(
                                team,
                                JoinRequestStatusForOverAllTeam.PENDING,
                                now.toLocalDate().atStartOfDay()
                        )
                )
                .expiringSoon(
                        joinRequestRepository.countExpiringBetween(
                                team,
                                JoinRequestStatusForOverAllTeam.PENDING,
                                now,
                                now.plusHours(24)
                        )
                )
                .requests(requests)
                .build();
    }

    /**
     * Approves a join request and adds player to roster.
     */
    @Transactional
    public void approveRequest(Long managerUserId,
                               Long teamId,
                               Long requestId) {

        Team team = getTeamAndVerify(managerUserId, teamId);
        TeamJoinRequest req = getRequestAndVerify(requestId, team);

        if (req.getExpiresAt() != null &&
                req.getExpiresAt().isBefore(LocalDateTime.now()))
            throw new IllegalStateException("request has expired");

        User player = req.getPlayer();

        if (teamMemberRepository.existsByTeamAndUser(team, player)) {

            TeamMember member = new TeamMember();
            member.setTeam(team);
            member.setUser(player);
            member.setMobileNumber(
                    player.getMobileNumber() != null ? player.getMobileNumber() : ""
            );

            String displayName =
                    (player.getEmail() != null && player.getEmail().contains("@"))
                            ? player.getEmail().split("@")[0]
                            : "Player";

            member.setDisplayName(displayName);
            member.setIsGuest(false);
            member.setAddMethod(PlayerAddMethod.TEAM_CODE);
            member.setAddedByScorerId(managerUserId);
            member.setCreatedAt(LocalDateTime.now());

            teamMemberRepository.save(member);
        }

        req.setStatus(JoinRequestStatus.APPROVED);
        req.setRespondedAt(LocalDateTime.now());
        joinRequestRepository.save(req);
    }

    /**
     * Rejects a join request.
     */
    @Transactional
    public void rejectRequest(Long managerUserId,
                              Long teamId,
                              Long requestId) {

        Team team = getTeamAndVerify(managerUserId, teamId);
        TeamJoinRequest req = getRequestAndVerify(requestId, team);

        req.setStatus(JoinRequestStatus.REJECTED);
        req.setRespondedAt(LocalDateTime.now());
        joinRequestRepository.save(req);
    }

    /**
     * Returns approval history (non-pending).
     */
    public List<PendingApprovalResponse> getHistory(Long managerUserId,
                                                    Long teamId) {

        Team team = getTeamAndVerify(managerUserId, teamId);

        return joinRequestRepository
                .findByTeamAndStatusNot(team, JoinRequestStatusForOverAllTeam.PENDING)
                .stream()
                .map(r -> buildCard(r, LocalDateTime.now()))
                .collect(Collectors.toList());
    }

    private PendingApprovalResponse buildCard(TeamJoinRequest r,
                                              LocalDateTime now) {

        User player = r.getPlayer();

        boolean expiringSoon =
                r.getExpiresAt() != null &&
                        r.getExpiresAt().isAfter(now) &&
                        r.getExpiresAt().isBefore(now.plusHours(24));

        String playerName =
                (player.getEmail() != null && player.getEmail().contains("@"))
                        ? player.getEmail().split("@")[0]
                        : "Player";

        return PendingApprovalResponse.builder()
                .requestId(r.getId())
                .playerId(player.getId())
                .playerName(playerName)
                .requestType(r.getType().name())
                .createdAt(r.getCreatedAt().format(DATE_FORMAT))
                .expiresAt(
                        r.getExpiresAt() != null
                                ? r.getExpiresAt().format(DATE_FORMAT)
                                : null
                )
                .isExpiringSoon(expiringSoon)
                .build();
    }

    private Team getTeamAndVerify(Long managerUserId, Long teamId) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!managerUserId.equals(team.getManagerUserId()))
            throw new IllegalStateException("Access denied");

        return team;
    }

    private TeamJoinRequest getRequestAndVerify(Long requestId,
                                                Team team) {

        TeamJoinRequest req = joinRequestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("request not found"));

        if (!req.getTeam().getId().equals(team.getId()))
            throw new IllegalStateException("request does not belong to this team");

        if (req.getStatus() != JoinRequestStatus.PENDING)
            throw new IllegalStateException("request is no longer pending");

        return req;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerDashboardService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

public class ManagerDashboardService {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerRecruitService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

public class ManagerRecruitService {


}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerRosterService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.domain.teams.*;
import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestStatus;
import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestType;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import in.crewplay.crewplay_backend.team.repository.TeamJoinRequestRepository;
import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team_manager.dto.request.AddGuestRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.InvitePlayerRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.RosterPlayerResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Handles roster management for Team Manager.
 * Includes invites, guest additions, roster view, and removal.
 */
@Service
@RequiredArgsConstructor
public class ManagerRosterService {

    private final TeamRepository teamRepository;
    private final UserRepository userRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final TeamJoinRequestRepository joinRequestRepository;

    /**
     * Invite existing platform user by mobile number.
     */
    @Transactional
    public String invitePlayerByMobile(Long managerUserId,
                                       Long teamId,
                                       InvitePlayerRequest req) {

        if (req.getMobileNumber() == null || req.getMobileNumber().isBlank())
            throw new IllegalArgumentException("Mobile number required");

        Team team = getTeamAndVerify(managerUserId, teamId);

        User manager = userRepository.findById(managerUserId)
                .orElseThrow(() -> new RuntimeException("Manager not found"));

        Optional<User> playerOpt = userRepository.findByMobileNumber(req.getMobileNumber());
        if (playerOpt.isEmpty())
            return "PLAYER_NOT_FOUND";

        User player = playerOpt.get();

        if (teamMemberRepository.existsByTeamAndUser(team, player))
            throw new IllegalStateException("Player already in team");

        // Check existing pending invite
        joinRequestRepository
                .findByTeamAndPlayerAndStatus(team, player, JoinRequestStatus.PENDING)
                .ifPresent(r -> {
                    if (r.getExpiresAt() != null && r.getExpiresAt().isAfter(LocalDateTime.now()))
                        throw new IllegalStateException("Invite already pending");
                });

        TeamJoinRequest invite = new TeamJoinRequest();
        invite.setTeam(team);
        invite.setPlayer(player);
        invite.setInitiatedBy(manager);
        invite.setType(JoinRequestType.MANAGER_INVITE);
        invite.setStatus(JoinRequestStatus.PENDING);
        invite.setMessage(req.getMessage());
        invite.setCreatedAt(LocalDateTime.now());
        invite.setExpiresAt(LocalDateTime.now().plusDays(7));

        joinRequestRepository.save(invite);

        return "INVITED";
    }

    /**
     * Add manual guest player (no platform account).
     */
    @Transactional
    public TeamMember addGuestPlayer(Long managerUserId,
                                     Long teamId,
                                     AddGuestRequest req) {

        if (req.getDisplayName() == null || req.getDisplayName().isBlank())
            throw new IllegalArgumentException("Display name required");

        Team team = getTeamAndVerify(managerUserId, teamId);

        // Prevent duplicate guest by mobile
        if (req.getMobileNumber() != null &&
                teamMemberRepository.existsByTeam_IdAndMobileNumber(teamId, req.getMobileNumber()))
            throw new IllegalStateException("Guest with this mobile already exists");

        TeamMember member = new TeamMember();
        member.setTeam(team);
        member.setUser(null);
        member.setDisplayName(req.getDisplayName());
        member.setMobileNumber(req.getMobileNumber());
        member.setIsGuest(true);
        member.setAddMethod(PlayerAddMethod.MANUAL_GUEST);
        member.setAddedByScorerId(managerUserId);
        member.setCreatedAt(LocalDateTime.now());

        return teamMemberRepository.save(member);
    }

    /**
     * Fetch full roster.
     */
    public List<RosterPlayerResponse> getRoster(Long managerUserId,
                                                Long teamId) {

        Team team = getTeamAndVerify(managerUserId, teamId);

        return teamMemberRepository.findByTeam_Id(teamId)
                .stream()
                .map(member -> RosterPlayerResponse.builder()
                        .memberId(member.getId())
                        .userId(member.getUser() != null ? member.getUser().getId() : null)
                        .displayName(member.getDisplayName())
                        .mobileNumber(member.getMobileNumber())
                        .addMethod(member.getAddMethod().name())
                        .isGuest(Boolean.TRUE.equals(member.getIsGuest()))
                        .verificationStatus(resolveVerificationStatus(member))
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Remove player from team.
     */
    @Transactional
    public void removePlayer(Long managerUserId,
                             Long teamId,
                             Long memberId) {

        getTeamAndVerify(managerUserId, teamId);

        TeamMember member = teamMemberRepository.findById(memberId)
                .orElseThrow(() -> new RuntimeException("Member not found"));

        if (!member.getTeam().getId().equals(teamId))
            throw new IllegalStateException("Member does not belong to this team");

        teamMemberRepository.delete(member);
    }

    /**
     * Ensures manager owns the team.
     */
    private Team getTeamAndVerify(Long managerUserId, Long teamId) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!managerUserId.equals(team.getManagerUserId()))
            throw new IllegalStateException("Access denied");

        return team;
    }

    /**
     * Determines verification label for UI.
     */
    private String resolveVerificationStatus(TeamMember member) {

        if (Boolean.TRUE.equals(member.getIsGuest()))
            return "Guest";

        if (member.getUser() != null)
            return "Verified";

        return "Pending";
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerSquadService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.teams.*;
import in.crewplay.crewplay_backend.domain.teams.enums.AvailabilityStatus;
import in.crewplay.crewplay_backend.team.repository.PlayerAvailabilityRepository;
import in.crewplay.crewplay_backend.team_manager.dto.request.ConfirmPlayingXiRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateAvailabilityRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.SquadPlayerCard;
import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.domain.match.repository.MatchRepository;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team_manager.dto.response.SquadManagementResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ManagerSquadService {

    private final MatchRepository matchRepository;
    private final PlayerAvailabilityRepository availabilityRepository;
    private final TeamRepository teamRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final UserRepository userRepository;

    /**
     * Returns full squad overview for match.
     */
    public SquadManagementResponse getSquadView(Long managerUserId,
                                                Long teamId,
                                                Long matchId) {

        Team team = getTeamAndVerify(managerUserId, teamId);
        Match match = validateMatchBelongsToTeam(matchId, teamId);

        List<TeamMember> members = teamMemberRepository.findByTeam_Id(teamId);

        Map<Long, PlayerAvailability> availabilityMap =
                availabilityRepository.findByMatchAndTeam(match, team)
                        .stream()
                        .filter(a -> a.getPlayer() != null)
                        .collect(Collectors.toMap(
                                a -> a.getPlayer().getId(),
                                a -> a
                        ));

        int available = 0, unavailable = 0, pending = 0, xiCount = 0;

        List<SquadPlayerCard> cards = new ArrayList<>();
        SquadPlayerCard captainCard = null;
        SquadPlayerCard wkCard = null;

        for (TeamMember member : members) {

            if (member.getUser() == null) continue;

            Long userId = member.getUser().getId();
            PlayerAvailability av = availabilityMap.get(userId);

            AvailabilityStatus status =
                    av != null ? av.getStatus() : AvailabilityStatus.PENDING;

            boolean inXi = av != null && Boolean.TRUE.equals(av.getIsInPlayingXi());
            boolean isCaptain = av != null && Boolean.TRUE.equals(av.getIsCaptain());
            boolean isWk = av != null && Boolean.TRUE.equals(av.getIsWicketKeeper());

            if (status == AvailabilityStatus.AVAILABLE) available++;
            else if (status == AvailabilityStatus.UNAVAILABLE
                    || status == AvailabilityStatus.INJURED) unavailable++;
            else pending++;

            if (inXi) xiCount++;

            SquadPlayerCard card = SquadPlayerCard.builder()
                    .userId(userId)
                    .displayName(member.getDisplayName())
                    .availabilityStatus(status.name())
                    .isInPlayingXi(inXi)
                    .isCaptain(isCaptain)
                    .isWicketKeeper(isWk)
                    .build();

            cards.add(card);

            if (isCaptain) captainCard = card;
            if (isWk) wkCard = card;
        }

        return SquadManagementResponse.builder()
                .matchId(matchId)
                .matchTitle("Match #" + matchId)
                .playingXiSelected(xiCount)
                .playingXiTotal(11)
                .totalSquad(cards.size())
                .available(available)
                .unavailable(unavailable)
                .pending(pending)
                .captain(captainCard)
                .wicketKeeper(wkCard)
                .players(cards)
                .isXiConfirmed(xiCount == 11)
                .build();
    }

    /**
     * Player sets availability for match.
     */
    @Transactional
    public void updatePlayerAvailability(Long playerUserId,
                                         Long teamId,
                                         UpdateAvailabilityRequest req) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        // Ensure player belongs to team
        if (!teamMemberRepository.existsByTeam_IdAndUser_Id(teamId, playerUserId))
            throw new IllegalStateException("Player not part of this team");

        Match match = validateMatchBelongsToTeam(req.getMatchId(), teamId);

        User player = userRepository.getReferenceById(playerUserId);

        PlayerAvailability availability =
                availabilityRepository
                        .findByMatchAndTeamAndPlayer(match, team, player)
                        .orElseGet(() -> {
                            PlayerAvailability a = new PlayerAvailability();
                            a.setMatch(match);
                            a.setTeam(team);
                            a.setPlayer(player);
                            a.setCreatedAt(LocalDateTime.now());
                            return a;
                        });

        availability.setStatus(req.getStatus());
        availability.setConfirmedAt(LocalDateTime.now());

        availabilityRepository.save(availability);
    }

    /**
     * Confirms Playing XI.
     */
    @Transactional
    public void confirmPlayingXi(Long managerUserId,
                                 Long teamId,
                                 ConfirmPlayingXiRequest req) {

        Team team = getTeamAndVerify(managerUserId, teamId);
        Match match = validateMatchBelongsToTeam(req.getMatchId(), teamId);

        List<Long> selected = req.getPlayerUserIds();

        if (selected == null || selected.size() != 11)
            throw new IllegalArgumentException("Playing XI must contain exactly 11 players");

        if (!selected.contains(req.getCaptainUserId()))
            throw new IllegalArgumentException("Captain must be in Playing XI");

        if (!selected.contains(req.getWicketKeeperUserId()))
            throw new IllegalArgumentException("Wicketkeeper must be in Playing XI");

        Set<Long> teamPlayerIds =
                teamMemberRepository.findByTeam_Id(teamId).stream()
                        .filter(m -> m.getUser() != null)
                        .map(m -> m.getUser().getId())
                        .collect(Collectors.toSet());

        for (Long userId : selected)
            if (!teamPlayerIds.contains(userId))
                throw new IllegalArgumentException("Player " + userId + " not in team");

        List<PlayerAvailability> existing =
                availabilityRepository.findByMatchAndTeam(match, team);

        for (PlayerAvailability a : existing) {
            a.setIsInPlayingXi(false);
            a.setIsCaptain(false);
            a.setIsWicketKeeper(false);
        }

        availabilityRepository.saveAll(existing);

        for (Long userId : selected) {

            User player = userRepository.getReferenceById(userId);

            PlayerAvailability availability =
                    availabilityRepository
                            .findByMatchAndTeamAndPlayer(match, team, player)
                            .orElseGet(() -> {
                                PlayerAvailability a = new PlayerAvailability();
                                a.setMatch(match);
                                a.setTeam(team);
                                a.setPlayer(player);
                                a.setCreatedAt(LocalDateTime.now());
                                return a;
                            });

            availability.setIsInPlayingXi(true);
            availability.setStatus(AvailabilityStatus.AVAILABLE);
            availability.setIsCaptain(userId.equals(req.getCaptainUserId()));
            availability.setIsWicketKeeper(userId.equals(req.getWicketKeeperUserId()));
            availability.setConfirmedAt(LocalDateTime.now());

            availabilityRepository.save(availability);
        }
    }

    private Team getTeamAndVerify(Long managerUserId, Long teamId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!managerUserId.equals(team.getManagerUserId()))
            throw new IllegalStateException("Access denied");

        return team;
    }

    private Match validateMatchBelongsToTeam(Long matchId, Long teamId) {

        Match match = matchRepository.findById(matchId)
                .orElseThrow(() -> new RuntimeException("Match not found"));

        if (!match.getTeamAId().equals(teamId)
                && !match.getTeamBId().equals(teamId))
            throw new IllegalStateException("Match does not belong to this team");

        return match;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/ManagerTeamService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.TeamMember;
import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.TeamManagerProfile;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.team_manager.Repository.TeamManagerProfileRepository;
import in.crewplay.crewplay_backend.team_manager.dto.request.CreateTeamManagerRequest;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateTeamRequest;
import in.crewplay.crewplay_backend.team_manager.dto.response.TeamSummaryResponse;
import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;


@Service
@RequiredArgsConstructor
public class ManagerTeamService {

    private final TeamRepository teamRepository;
    private final UserRepository userRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final TeamManagerProfileRepository profileRepository;
    private final in.crewplay.crewplay_backend.team.util.TeamCodeGenerator teamCodeGenerator;

    /**
     * Manager creates a team (Manager Mode).
     * Team is ACTIVE immediately.
     */
    @Transactional
    public Team createTeam(Long managerUserId, CreateTeamManagerRequest request) {

        if (request.getTeamName() == null || request.getTeamName().isBlank())
            throw new IllegalArgumentException("Team name is required");

        if (request.getCity() == null || request.getCity().isBlank())
            throw new IllegalArgumentException("City is required");

        if (teamRepository.existsByNameAndCity(request.getTeamName(), request.getCity()))
            throw new IllegalStateException("Team already exists in " + request.getCity());

        User manager = userRepository.findById(managerUserId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        User captain = resolveCaptain(request, manager);

        Team team = new Team();
        team.setName(request.getTeamName());
        team.setCity(request.getCity());
        team.setLogoUrl(request.getLogoUrl());
        team.setHomeGround(request.getHomeGround());
        team.setTeamCode(teamCodeGenerator.generate());
        team.setCaptain(captain);
        team.setManagerUserId(managerUserId);
        team.setCreatedByScorerId(managerUserId);
        team.setStatus(TeamStatus.ACTIVE);
        team.setCreatedAt(LocalDateTime.now());

        Team saved = teamRepository.save(team);

        addMemberToTeam(saved, manager, managerUserId);

        if (!captain.getId().equals(managerUserId))
            addMemberToTeam(saved, captain, managerUserId);

        // Update manager profile
        TeamManagerProfile profile = profileRepository.findById(managerUserId)
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        profile.setActiveTeamId(saved.getId());
        profile.setTeamsHandledCount(profile.getTeamsHandledCount() + 1);
        profile.setUpdatedAt(LocalDateTime.now());
        profileRepository.save(profile);

        return saved;
    }

    public List<TeamSummaryResponse> getMyTeams(Long managerUserId) {

        Long activeTeamId = profileRepository.findById(managerUserId)
                .map(TeamManagerProfile::getActiveTeamId)
                .orElse(null);

        return teamRepository.findByManagerUserId(managerUserId)
                .stream()
                .map(team -> buildTeamSummary(team, activeTeamId))
                .collect(Collectors.toList());
    }

    @Transactional
    public Team updateTeam(Long managerUserId, Long teamId, UpdateTeamRequest req) {

        Team team = getTeamAndVerifyOwner(managerUserId, teamId);

        if (req.getTeamName() != null) team.setName(req.getTeamName());
        if (req.getLogoUrl() != null) team.setLogoUrl(req.getLogoUrl());
        if (req.getHomeGround() != null) team.setHomeGround(req.getHomeGround());
        if (req.getActiveLeague() != null) team.setActiveLeague(req.getActiveLeague());

        return teamRepository.save(team);
    }

    @Transactional
    public void recordMatchResult(Long teamId, boolean won, boolean lost, boolean drawn) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (won) team.setWins(team.getWins() + 1);
        if (lost) team.setLosses(team.getLosses() + 1);
        if (drawn) team.setDraws(team.getDraws() + 1);

        teamRepository.save(team);
    }

    public Team getTeamAndVerifyOwner(Long managerUserId, Long teamId) {

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!managerUserId.equals(team.getManagerUserId()))
            throw new IllegalStateException("Access denied");

        return team;
    }

    private User resolveCaptain(CreateTeamManagerRequest request, User manager) {

        if (request.isMakeManagerCaptain()) {
            return manager;
        }

        if (request.getCaptainMobileNumber() == null || request.getCaptainMobileNumber().isBlank())
            throw new IllegalArgumentException("Captain mobile required");

        return userRepository.findByMobileNumber(request.getCaptainMobileNumber())
                .orElseThrow(() -> new RuntimeException("Captain not found"));
    }

    private void addMemberToTeam(Team team, User user, Long addedBy) {

        if (teamMemberRepository.existsByTeamAndUser(team, user)) {

            TeamMember m = new TeamMember();
            m.setTeam(team);
            m.setUser(user);

            String displayName = (user.getEmail() != null && user.getEmail().contains("@"))
                    ? user.getEmail().split("@")[0]
                    : "Player";

            m.setDisplayName(displayName);
            m.setMobileNumber(user.getMobileNumber() != null ? user.getMobileNumber() : "");
            m.setAddMethod(PlayerAddMethod.TEAM_CODE);
            m.setAddedByScorerId(addedBy);
            m.setIsGuest(false);
            m.setCreatedAt(LocalDateTime.now());

            teamMemberRepository.save(m);
        }
    }

    private TeamSummaryResponse buildTeamSummary(Team t, Long activeTeamId) {

        int totalPlayers = Math.toIntExact(teamMemberRepository.countByTeam_Id(t.getId()));

        return TeamSummaryResponse.builder()
                .teamId(t.getId())
                .teamName(t.getName())
                .logoUrl(t.getLogoUrl())
                .homeGround(t.getHomeGround())
                .activeLeague(t.getActiveLeague())
                .status(t.getStatus().name())
                .wins(t.getWins())
                .losses(t.getLosses())
                .draws(t.getDraws())
                .isCurrentActive(t.getId().equals(activeTeamId))
                .teamCode(t.getTeamCode())
                .totalPlayers(totalPlayers)
                .build();
    }

    @Transactional
    public void switchActiveTeam(Long userId, Long teamId) {

        TeamManagerProfile profile = profileRepository
                .findByUserId(userId)
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        Team team = teamRepository
                .findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        profile.setActiveTeam(team);
        profileRepository.save(profile);
    }

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_manager/Service/TeamManagerProfileService.java">
package in.crewplay.crewplay_backend.team_manager.Service;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.user.TeamManagerProfile;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.team_manager.Repository.TeamManagerProfileRepository;
import in.crewplay.crewplay_backend.team_manager.dto.response.TeamManagerProfileResponse;
import in.crewplay.crewplay_backend.team_manager.dto.request.UpdateManagerProfileRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * service handling Team Manager profile lifecycle and stats.
 * Responsible for:
 * - Auto profile creation
 * - Profile updates
 * - Career stats tracking
 * - Active team switching
 */
@Service
@RequiredArgsConstructor
public class TeamManagerProfileService {

    private final TeamManagerProfileRepository profileRepository;
    private final UserRepository userRepository;
    private final TeamRepository teamRepository;

    /**
     * Creates manager profile if not already present.
     * Uses @MapsId (profile.id == user.id).
     */
    @Transactional
    public TeamManagerProfile getOrCreateProfile(Long userId) {

        return profileRepository.findById(userId).orElseGet(() -> {

            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found"));

            TeamManagerProfile profile = new TeamManagerProfile();
            profile.setUser(user); // @MapsId sets ID automatically

            // Safe default name
            String defaultName = (user.getEmail() != null && user.getEmail().contains("@"))
                    ? user.getEmail().split("@")[0]
                    : "Manager";

            profile.setName(defaultName);
            profile.setEmail(user.getEmail());
            profile.setMobileNumber(user.getMobileNumber());

            profile.setMemberSince(LocalDateTime.now());
            profile.setCreatedAt(LocalDateTime.now());

            // Default permissions
            profile.setCanScheduleMatches(true);
            profile.setCanRecruitPlayers(true);
            profile.setCanManageFinances(false);
            profile.setIsVerifiedManager(false);

            return profileRepository.save(profile);
        });
    }

    /**
     * Builds full profile response (Screen 16).
     * Derived fields like winRate are computed dynamically.
     */
    public TeamManagerProfileResponse buildProfileResponse(Long userId) {

        TeamManagerProfile p = getOrCreateProfile(userId);

        double winRate = 0.0;
        if (p.getTotalMatchesManaged() > 0) {
            winRate = ((double) p.getTotalWins() / p.getTotalMatchesManaged()) * 100;
        }

        String memberSince = (p.getMemberSince() != null)
                ? p.getMemberSince().format(DateTimeFormatter.ofPattern("MMMM yyyy"))
                : "Unknown";

        return TeamManagerProfileResponse.builder()
                .userId(userId)
                .name(p.getName())
                .email(p.getEmail())
                .mobileNumber(p.getMobileNumber())
                .city(p.getCity())
                .profileImageUrl(p.getProfileImageUrl())
                .followersCount(p.getFollowersCount())
                .followingCount(p.getFollowingCount())
                .totalSeasons(p.getTotalSeasons())
                .totalMatchesManaged(p.getTotalMatchesManaged())
                .totalWins(p.getTotalWins())
                .totalLosses(p.getTotalLosses())
                .winRate(round(winRate))
                .formRating(p.getFormRating())
                .managerRank(p.getManagerRank())
                .activeTeamId(p.getActiveTeamId())
                .canScheduleMatches(p.getCanScheduleMatches())
                .canRecruitPlayers(p.getCanRecruitPlayers())
                .canManageFinances(p.getCanManageFinances())
                .isVerifiedManager(p.getIsVerifiedManager())
                .memberSince(memberSince)
                .teamsHandledCount(p.getTeamsHandledCount())
                .build();
    }

    /**
     * Updates editable profile fields.
     */
    @Transactional
    public TeamManagerProfile updateProfile(Long userId,
                                            UpdateManagerProfileRequest req) {

        TeamManagerProfile profile = getOrCreateProfile(userId);

        if (req.getName() != null) profile.setName(req.getName());
        if (req.getProfileImageUrl() != null) profile.setProfileImageUrl(req.getProfileImageUrl());
        if (req.getCity() != null) profile.setCity(req.getCity());
        if (req.getMobileNumber() != null) profile.setMobileNumber(req.getMobileNumber());

        profile.setUpdatedAt(LocalDateTime.now());
        return profileRepository.save(profile);
    }

    /**
     * Updates manager career stats after match completion.
     * Should be triggered from match-completion hook.
     */
    @Transactional
    public void recordMatchResult(Long managerUserId,
                                  boolean won,
                                  boolean lost) {

        TeamManagerProfile profile = getOrCreateProfile(managerUserId);

        profile.setTotalMatchesManaged(profile.getTotalMatchesManaged() + 1);

        if (won) profile.setTotalWins(profile.getTotalWins() + 1);
        if (lost) profile.setTotalLosses(profile.getTotalLosses() + 1);

        profile.setUpdatedAt(LocalDateTime.now());
        profileRepository.save(profile);
    }

    /**
     * Switches active team.
     * Validates ownership before switching.
     */
    @Transactional
    public void switchActiveTeam(Long userId, Long teamId) {

        TeamManagerProfile profile = getOrCreateProfile(userId);

        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found"));

        if (!userId.equals(team.getManagerUserId())) {
            throw new IllegalStateException("You do not manage this team");
        }

        profile.setActiveTeamId(teamId);
        profile.setUpdatedAt(LocalDateTime.now());
        profileRepository.save(profile);
    }

    /**
     * Soft delete account (deactivates user).
     * Historical data remains for audit integrity.
     */
    @Transactional
    public void deleteAccount(Long userId) {

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setIsActive(false);
        userRepository.save(user);
    }

    private double round(double value) {
        return Math.round(value * 10.0) / 10.0;
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/controller/TeamRosterController.java">
package in.crewplay.crewplay_backend.team_roster.controller;

public class TeamRosterController {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddGuestPlayerRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddGuestPlayerRequest {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/request/AddPlayerByMobileRequest.java">
package in.crewplay.crewplay_backend.team_roster.dto.request;

public class AddPlayerByMobileRequest {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/dto/response/TeamMemberResponse.java">
package in.crewplay.crewplay_backend.team_roster.dto.response;

public class TeamMemberResponse {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/repository/TeamMemberRepository.java">
package in.crewplay.crewplay_backend.team_roster.repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.TeamMember;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamMemberRepository extends JpaRepository<TeamMember, Long> {

    Optional<TeamMember> findByTeamAndUser(Team team, User user);

    List<TeamMember> findByTeam(Team team);

    List<TeamMember> findByTeam_Id(Long teamId);

    boolean existsByTeam_IdAndUser_Id(Long teamId, Long userId);


    boolean existsByTeamAndUser(Team team, User user);


    boolean existsByTeam_IdAndMobileNumber(Long teamId, String mobileNumber);

    long countByTeam_Id(Long teamId);



}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team_roster/service/TeamRosterService.java">
package in.crewplay.crewplay_backend.team_roster.service;

public class TeamRosterService {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/Controller/TeamController.java">
package in.crewplay.crewplay_backend.team.Controller;


import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.team.Service.TeamService;
import in.crewplay.crewplay_backend.team.dto.request.CreateTeamRequest;
import in.crewplay.crewplay_backend.team.dto.request.VerifyCaptainRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/teams")
@RequiredArgsConstructor
public class TeamController {

    private final TeamService teamService;

    /**
     * STEP 1  Send captain verification OTP (EMAIL)
     */
    @PostMapping("/verify-captain")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<String> verifyCaptain(
            @RequestBody VerifyCaptainRequest request
    ) {
        teamService.sendCaptainVerificationOtp(request.getCaptainEmail());
        return ResponseEntity.ok("OTP sent to captain email");
    }

    /**
     * STEP 2  Create team (OTP already verified on frontend)
     */
    @PostMapping("/create")
    @PreAuthorize("hasRole('SCORER')")
    public ResponseEntity<Team> createTeam(
            @RequestAttribute("userId") Long scorerUserId,
            @RequestBody CreateTeamRequest request
    ) {
        Team team = teamService.createTeam(
                scorerUserId,
                request.getTeamName(),
                request.getCity(),
                request.getLogoUrl(),
                request.getCaptainMobileNumber()
        );
        return ResponseEntity.ok(team);
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/request/CreateTeamRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class CreateTeamRequest {

    private String teamName;
    private String city;
    private String logoUrl;
    private String captainMobileNumber;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/request/VerifyCaptainRequest.java">
package in.crewplay.crewplay_backend.team.dto.request;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class VerifyCaptainRequest {
    private String captainEmail;
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/dto/response/TeamResponse.java">
package in.crewplay.crewplay_backend.team.dto.response;

public class TeamResponse {
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/AvailabilityStatusForOverAllTeam.java">
package in.crewplay.crewplay_backend.team.enums;
public enum AvailabilityStatusForOverAllTeam {
    AVAILABLE,
    UNAVAILABLE,
    INJURED,
    PENDING
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/JoinRequestStatusForOverAllTeam.java">
package in.crewplay.crewplay_backend.team.enums;

public enum JoinRequestStatusForOverAllTeam {
    PENDING,
    APPROVED,
    REJECTED,
    EXPIRED,
    CANCELLED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/JoinRequestTypeForOverAllTeam.java">
package in.crewplay.crewplay_backend.team.enums;
public enum JoinRequestTypeForOverAllTeam {
    PLAYER_REQUEST,
    MANAGER_INVITE,
    LINK_JOIN,
    QR_JOIN,
    TEAM_CODE_JOIN
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/enums/TeamStatusForOverAllTeam.java">
package in.crewplay.crewplay_backend.team.enums;

public enum TeamStatusForOverAllTeam {

    TEMPORARY,   // Created inside match flow
    ACTIVE,      // Permanent team
    ARCHIVED
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/PlayerAvailabilityRepository.java">
package in.crewplay.crewplay_backend.team.repository;

import in.crewplay.crewplay_backend.domain.match.Match;
import in.crewplay.crewplay_backend.domain.teams.PlayerAvailability;
import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.enums.AvailabilityStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface PlayerAvailabilityRepository
        extends JpaRepository<PlayerAvailability, Long> {

    // Load full squad state
    List<PlayerAvailability> findByMatchAndTeam(Match match, Team team);

    // Find specific player availability
    Optional<PlayerAvailability> findByMatchAndTeamAndPlayer(
            Match match,
            Team team,
            User player
    );

    // Filter by availability status
    List<PlayerAvailability> findByMatchAndTeamAndStatus(
            Match match,
            Team team,
            AvailabilityStatus status
    );

    // Selected Playing XI
    List<PlayerAvailability> findByMatchAndTeamAndIsInPlayingXiTrue(
            Match match,
            Team team
    );

    int countByMatchAndTeamAndIsInPlayingXiTrue(
            Match match,
            Team team
    );

    // Count by status
    int countByMatchAndTeamAndStatus(
            Match match,
            Team team,
            AvailabilityStatus status
    );

    // Captain lookup
    Optional<PlayerAvailability> findByMatchAndTeamAndIsCaptainTrue(
            Match match,
            Team team
    );

    // Wicketkeeper lookup
    Optional<PlayerAvailability> findByMatchAndTeamAndIsWicketKeeperTrue(
            Match match,
            Team team
    );
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamJoinRequestRepository.java">
package in.crewplay.crewplay_backend.team.repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.TeamJoinRequest;
import in.crewplay.crewplay_backend.domain.teams.enums.JoinRequestStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.team.enums.JoinRequestStatusForOverAllTeam;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * repository for handling team join requests.
 * Supports both player requests and manager invites.
 */
public interface TeamJoinRequestRepository extends JpaRepository<TeamJoinRequest, Long> {

    /**
     * Fetch all requests for a team by status.
     */
    List<TeamJoinRequest> findByTeamAndStatus(Team team, JoinRequestStatusForOverAllTeam status);

    /**
     * Count requests for a team by status.
     */
    int countByTeamAndStatus(Team team, JoinRequestStatusForOverAllTeam status);

    /**
     * Check if a specific player already has a request in a given status.
     */
    Optional<TeamJoinRequest> findByTeamAndPlayerAndStatus(
            Team team,
            User player,
            JoinRequestStatus status
    );

    /**
     * Fetch request history excluding a particular status (e.g., not PENDING).
     */
    List<TeamJoinRequest> findByTeamAndStatusNot(
            Team team,
            JoinRequestStatusForOverAllTeam status
    );

    /**
     * Count new requests created after a certain time.
     */
    @Query("""
        SELECT COUNT(r) FROM TeamJoinRequest r
        WHERE r.team = :team
          AND r.status = :status
          AND r.createdAt >= :since
    """)
    int countNewSince(
            @Param("team") Team team,
            @Param("status") JoinRequestStatusForOverAllTeam status,
            @Param("since") LocalDateTime since
    );

    /**
     * Count requests expiring within a time window.
     */
    @Query("""
        SELECT COUNT(r) FROM TeamJoinRequest r
        WHERE r.team = :team
          AND r.status = :status
          AND r.expiresAt BETWEEN :now AND :soon
    """)
    int countExpiringBetween(
            @Param("team") Team team,
            @Param("status") JoinRequestStatusForOverAllTeam status,
            @Param("now") LocalDateTime now,
            @Param("soon") LocalDateTime soon
    );
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamPlayerRepository.java">
package in.crewplay.crewplay_backend.team.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface TeamPlayerRepository extends JpaRepository<TeamPlayer, Long> {

    boolean existsByTeamIdAndUserId(Long teamId, Long userId);

    List<TeamPlayer> findByTeamIdAndIsActiveTrue(Long teamId);
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/repository/TeamRepository.java">
package in.crewplay.crewplay_backend.team.repository;

import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface TeamRepository extends JpaRepository<Team, Long> {

    Optional<Team> findByTeamCode(String teamCode);

    List<Team> findByCreatedByScorerId(Long scorerId);

    boolean existsByNameAndCity(String name, String city);

    List<Team> findByCaptainAndStatus(User captain, TeamStatus status);

    List<Team> findByManagerUserId(Long managerUserId);
    List<Team> findByCaptain(User captain);

}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/Service/TeamService.java">
package in.crewplay.crewplay_backend.team.Service;

import in.crewplay.crewplay_backend.Auth.service.OtpService;
import in.crewplay.crewplay_backend.common.enums.PlayerAddMethod;
import in.crewplay.crewplay_backend.domain.teams.Team;
import in.crewplay.crewplay_backend.domain.teams.enums.TeamStatus;
import in.crewplay.crewplay_backend.domain.user.User;
import in.crewplay.crewplay_backend.domain.user.repository.UserRepository;
import in.crewplay.crewplay_backend.team.repository.TeamRepository;
import in.crewplay.crewplay_backend.team.util.TeamCodeGenerator;
import in.crewplay.crewplay_backend.team_roster.repository.TeamMemberRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class TeamService {

    private final TeamRepository teamRepository;
    private final UserRepository userRepository;
    private final TeamMemberRepository teamMemberRepository;
    private final OtpService otpService;
    private final TeamCodeGenerator teamCodeGenerator;

    /**
     * STEP 1  Send captain verification OTP (EMAIL)
     */
    public void sendCaptainVerificationOtp(String captainEmail) {
        otpService.generateAndStoreOtp(captainEmail);
    }

    /**
     * STEP 2  Create Team (OTP already verified)
     *
     * IMPORTANT:
     * - Team is created as TEMPORARY
     * - TEAM_MANAGER role is NOT assigned here
     * - Ownership will be granted after match completion
     */
    @Transactional
    public Team createTeam(
            Long scorerUserId,
            String teamName,
            String city,
            String logoUrl,
            String captainMobileNumber
    ) {

        // 1 Prevent duplicate team in same city
        if (teamRepository.existsByNameAndCity(teamName, city)) {
            throw new RuntimeException("Team already exists in this city");
        }

        // 2 Captain must be an existing user
        User captain = userRepository.findByMobileNumber(captainMobileNumber)
                .orElseThrow(() -> new RuntimeException("Captain must be an existing user"));

        // 3 Generate team code
        String teamCode = teamCodeGenerator.generate();

        // 4 Create TEMPORARY team
        Team team = new Team();
        team.setName(teamName);
        team.setCity(city);
        team.setLogoUrl(logoUrl);
        team.setTeamCode(teamCode);
        team.setCaptain(captain);
        team.setCreatedByScorerId(scorerUserId);
        team.setVerificationMethod("EMAIL");
        team.setStatus(TeamStatus.TEMPORARY); //  CRITICAL CHANGE
        team.setCreatedAt(LocalDateTime.now());

        Team savedTeam = teamRepository.save(team);

        // 5 Add captain to roster
        TeamMember captainMember = new TeamMember();
        captainMember.setTeam(savedTeam);
        captainMember.setUser(captain);
        captainMember.setDisplayName(extractDisplayName(captain));
        captainMember.setMobileNumber(captainMobileNumber);
        captainMember.setAddMethod(PlayerAddMethod.TEAM_CODE);
        captainMember.setIsGuest(false);
        captainMember.setReported(false);
        captainMember.setAddedByScorerId(scorerUserId);
        captainMember.setCreatedAt(LocalDateTime.now());

        teamMemberRepository.save(captainMember);

        //  REMOVED:
        // assignTeamManagerRoleIfMissing(captain);

        return savedTeam;
    }

    /**
     * Fallback display name logic (Phase-0 safe)
     */
    private String extractDisplayName(User user) {
        if (user.getEmail() != null) {
            return user.getEmail().split("@")[0];
        }
        return user.getMobileNumber();
    }
}
</file>

<file path="my-backend-main/src/main/java/in/crewplay/crewplay_backend/team/util/TeamCodeGenerator.java">
package in.crewplay.crewplay_backend.team.util;

import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class TeamCodeGenerator {

    public String generate() {
        return UUID.randomUUID()
                .toString()
                .substring(0, 8)
                .toUpperCase();
    }
}
</file>

<file path="my-backend-main/src/main/resources/application.yaml">
server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/crewplay
    username: crewplay
    password: crewplay
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    open-in-view: false

  redis:
    port: 6379

  mail:
    host: smtp.gmail.com
    port: 587
    username: your_email@gmail.com
    password: your_app_password
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
  data:
    redis:
      host: localhost

jwt:
  # This secret MUST be at least 32 characters for HS256
  secret: crewplay-super-secret-key-must-be-long-enough-32chars
  expiration: 86400000 # 1 day
</file>

<file path="my-backend-main/src/test/java/in/crewplay/crewplay_backend/CrewplayBackendApplicationTests.java">
package in.crewplay.crewplay_backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CrewplayBackendApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

</files>
